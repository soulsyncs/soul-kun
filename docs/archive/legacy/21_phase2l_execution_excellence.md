# ç¬¬21ç« ï¼šPhase 2L - å®Ÿè¡ŒåŠ›å¼·åŒ–ï¼ˆExecution Excellenceï¼‰

## 21.1 æ¦‚è¦

**å®Œç’§ã«ã‚„ã‚Šé‚ã’ã‚‹èƒ½åŠ›ã®å®Ÿç¾**

Phase 2Lã¯ã€ã‚½ã‚¦ãƒ«ãã‚“ãŒã€ŒæŒ‡ç¤ºã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ç¢ºå®Ÿã«å®Œé‚ã™ã‚‹ã€èƒ½åŠ›ã‚’å®Ÿè£…ã™ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã§ã™ã€‚
å˜ç´”ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œã‹ã‚‰ã€è¤‡é›‘ãªãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è‡ªå‹•å®Ÿè¡Œã¾ã§å¯¾å¿œã—ã¾ã™ã€‚

### ä½ç½®ã¥ã‘

```
Phase 2K: èƒ½å‹•æ€§ï¼ˆProactivityï¼‰âœ… å®Œäº†
    â”‚
    â–¼
Phase 2L: å®Ÿè¡ŒåŠ›å¼·åŒ–ï¼ˆExecution Excellenceï¼‰â† ä»Šã“ã“
    â”‚
    â–¼
Phase 2M: å¯¾äººåŠ›å¼·åŒ–ï¼ˆInterpersonal Skillsï¼‰
```

### ä¾å­˜é–¢ä¿‚

| ä¾å­˜Phase | æä¾›ã•ã‚Œã‚‹èƒ½åŠ› | Phase 2Lã§ã®æ´»ç”¨ |
|-----------|---------------|------------------|
| Phase 2K | ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç›£è¦– | é€²æ—ç›£è¦–ã€ãƒªãƒã‚¤ãƒ³ãƒ‰ |
| Phase 2J | åˆ¤æ–­åŠ›å¼·åŒ– | ã‚¿ã‚¹ã‚¯å„ªå…ˆåº¦åˆ¤æ–­ã€ãƒªã‚¹ã‚¯è©•ä¾¡ |
| Phase 2I | ç†è§£åŠ›å¼·åŒ– | æ›–æ˜§ãªæŒ‡ç¤ºã®è§£é‡ˆ |
| Phase 2E | å­¦ç¿’åŸºç›¤ | å®Ÿè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’ |

---

## 21.2 å®Ÿè£…ã™ã‚‹èƒ½åŠ›

### èƒ½åŠ›ä¸€è¦§

| # | èƒ½åŠ›å | èª¬æ˜ | å„ªå…ˆåº¦ |
|---|--------|------|--------|
| 1 | ã‚¿ã‚¹ã‚¯è‡ªå‹•åˆ†è§£ | è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã«åˆ†è§£ | é«˜ |
| 2 | å®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆ | ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ã¨å®Ÿè¡Œé †åºã‚’æ±ºå®š | é«˜ |
| 3 | é€²æ—è‡ªå‹•è¿½è·¡ | å„ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®é€²æ—ã‚’è¿½è·¡ | é«˜ |
| 4 | å“è³ªãƒã‚§ãƒƒã‚¯ | å®Ÿè¡Œçµæœã®å“è³ªã‚’æ¤œè¨¼ | ä¸­ |
| 5 | ä¾‹å¤–å‡¦ç† | ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®è‡ªå‹•ãƒªã‚«ãƒãƒªãƒ¼ | ä¸­ |
| 6 | ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | è‡ªå‹•è§£æ±ºä¸å¯ã®å ´åˆã«äººé–“ã«ç¢ºèª | ä¸­ |
| 7 | ä»£æ›¿æ¡ˆæç¤º | å¤±æ•—æ™‚ã®ä»£æ›¿ã‚¢ãƒ—ãƒ­ãƒ¼ãƒææ¡ˆ | ä¸­ |
| 8 | å®Œäº†ç¢ºèª | ã‚¿ã‚¹ã‚¯å®Œäº†ã®ç¢ºèªã¨å ±å‘Š | é«˜ |

---

## 21.3 ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### 21.3.1 å…¨ä½“æ§‹æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SoulkunBrain.process_message()            â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Understandingâ”‚â†’â”‚  Decision   â”‚â†’â”‚  ExecutionExcellence    â”‚ â”‚
â”‚  â”‚    Layer    â”‚  â”‚    Layer    â”‚  â”‚       Layer             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                  â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                   â”‚
                                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ExecutionExcellence                           â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    TaskDecomposer                         â”‚  â”‚
â”‚  â”‚  ã€Œã€‡ã€‡ã‚’æ‰‹é…ã—ã¦ã€â†’ ã‚µãƒ–ã‚¿ã‚¹ã‚¯1, 2, 3...ã«åˆ†è§£           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    ExecutionPlanner                       â”‚  â”‚
â”‚  â”‚  ä¾å­˜é–¢ä¿‚ã‚’è§£æ â†’ å®Ÿè¡Œé †åºã‚’æ±ºå®š â†’ ExecutionPlanã‚’ç”Ÿæˆ    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    WorkflowExecutor                       â”‚  â”‚
â”‚  â”‚  ExecutionPlanã«å¾“ã£ã¦ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡/ä¸¦åˆ—å®Ÿè¡Œ          â”‚  â”‚
â”‚  â”‚  â”œâ”€ ProgressTrackerï¼ˆé€²æ—è¿½è·¡ï¼‰                          â”‚  â”‚
â”‚  â”‚  â”œâ”€ QualityCheckerï¼ˆå“è³ªãƒã‚§ãƒƒã‚¯ï¼‰                       â”‚  â”‚
â”‚  â”‚  â”œâ”€ ExceptionHandlerï¼ˆä¾‹å¤–å‡¦ç†ï¼‰                         â”‚  â”‚
â”‚  â”‚  â””â”€ EscalationManagerï¼ˆã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    CompletionVerifier                     â”‚  â”‚
â”‚  â”‚  å…¨ã‚µãƒ–ã‚¿ã‚¹ã‚¯å®Œäº†ç¢ºèª â†’ æœ€çµ‚å“è³ªãƒã‚§ãƒƒã‚¯ â†’ å®Œäº†å ±å‘Š      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 21.3.2 ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```
1. å…¥åŠ›å—ä»˜
   ãƒ¦ãƒ¼ã‚¶ãƒ¼: ã€Œä¼šè­°å®¤Aã‚’æ˜æ—¥14æ™‚ã§äºˆç´„ã—ã¦ã€å‚åŠ è€…ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ‹›å¾…é€ã£ã¦ã€
        â”‚
        â–¼
2. ã‚¿ã‚¹ã‚¯åˆ†è§£ï¼ˆTaskDecomposerï¼‰
   â”œâ”€ SubTask1: ä¼šè­°å®¤Aã®ç©ºãç¢ºèªï¼ˆæ˜æ—¥14æ™‚ï¼‰
   â”œâ”€ SubTask2: ä¼šè­°å®¤Aã®äºˆç´„
   â”œâ”€ SubTask3: å‚åŠ è€…ãƒªã‚¹ãƒˆã®å–å¾—
   â””â”€ SubTask4: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ‹›å¾…é€ä¿¡
        â”‚
        â–¼
3. å®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆï¼ˆExecutionPlannerï¼‰
   ExecutionPlan:
   â”œâ”€ Step1: SubTask1ï¼ˆç©ºãç¢ºèªï¼‰
   â”‚      â””â”€ æˆåŠŸ â†’ Step2ã¸
   â”‚      â””â”€ å¤±æ•— â†’ ä»£æ›¿æ¡ˆæç¤ºï¼ˆåˆ¥ã®æ™‚é–“ã‚’ææ¡ˆï¼‰
   â”œâ”€ Step2: SubTask2ï¼ˆäºˆç´„ï¼‰[ä¾å­˜: Step1]
   â”œâ”€ Step3: SubTask3ï¼ˆå‚åŠ è€…å–å¾—ï¼‰[ä¸¦åˆ—å®Ÿè¡Œå¯]
   â””â”€ Step4: SubTask4ï¼ˆæ‹›å¾…é€ä¿¡ï¼‰[ä¾å­˜: Step2, Step3]
        â”‚
        â–¼
4. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œï¼ˆWorkflowExecutorï¼‰
   â”œâ”€ Step1å®Ÿè¡Œ â†’ æˆåŠŸ
   â”œâ”€ Step2å®Ÿè¡Œ â†’ æˆåŠŸ
   â”œâ”€ Step3å®Ÿè¡Œ â†’ æˆåŠŸ
   â””â”€ Step4å®Ÿè¡Œ â†’ æˆåŠŸ
        â”‚
        â–¼
5. å®Œäº†ç¢ºèªï¼ˆCompletionVerifierï¼‰
   â”œâ”€ å…¨ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†ç¢ºèª â†’ OK
   â”œâ”€ å“è³ªãƒã‚§ãƒƒã‚¯ â†’ OK
   â””â”€ å®Œäº†å ±å‘Šç”Ÿæˆ
        â”‚
        â–¼
6. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®å ±å‘Š
   ã€Œä¼šè­°å®¤Aã‚’æ˜æ—¥14æ™‚ã§äºˆç´„ã—ãŸã‚¦ãƒ«ï¼
    å‚åŠ è€…5åã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ‹›å¾…ã‚‚é€ã£ãŸã‚¦ãƒ«ğŸºã€
```

---

## 21.4 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### 21.4.1 Enumå®šç¾©

```python
# lib/brain/execution_excellence/models.py

from enum import Enum

class SubTaskStatus(str, Enum):
    """ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""
    PENDING = "pending"           # å®Ÿè¡Œå¾…ã¡
    IN_PROGRESS = "in_progress"   # å®Ÿè¡Œä¸­
    COMPLETED = "completed"       # å®Œäº†
    FAILED = "failed"             # å¤±æ•—
    BLOCKED = "blocked"           # ãƒ–ãƒ­ãƒƒã‚¯ä¸­ï¼ˆä¾å­˜ã‚¿ã‚¹ã‚¯å¾…ã¡ï¼‰
    SKIPPED = "skipped"           # ã‚¹ã‚­ãƒƒãƒ—ï¼ˆä¸è¦ã«ãªã£ãŸï¼‰
    ESCALATED = "escalated"       # ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¸ˆã¿

class ExecutionPriority(str, Enum):
    """å®Ÿè¡Œå„ªå…ˆåº¦"""
    CRITICAL = "critical"   # æœ€å„ªå…ˆï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
    HIGH = "high"           # é«˜ï¼ˆã§ãã‚‹ã ã‘æ—©ãï¼‰
    NORMAL = "normal"       # é€šå¸¸
    LOW = "low"             # ä½ï¼ˆä»–ã®ã‚¿ã‚¹ã‚¯å®Œäº†å¾Œï¼‰

class RecoveryStrategy(str, Enum):
    """ãƒªã‚«ãƒãƒªãƒ¼æˆ¦ç•¥"""
    RETRY = "retry"                 # ãƒªãƒˆãƒ©ã‚¤
    ALTERNATIVE = "alternative"     # ä»£æ›¿ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
    SKIP = "skip"                   # ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã‚¿ã‚¹ã‚¯ï¼‰
    ESCALATE = "escalate"           # äººé–“ã«ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    ABORT = "abort"                 # å…¨ä½“ã‚’ä¸­æ­¢

class QualityCheckResult(str, Enum):
    """å“è³ªãƒã‚§ãƒƒã‚¯çµæœ"""
    PASS = "pass"               # åˆæ ¼
    WARNING = "warning"         # è­¦å‘Šã‚ã‚Šï¼ˆç¶šè¡Œå¯ï¼‰
    FAIL = "fail"               # ä¸åˆæ ¼ï¼ˆä¿®æ­£å¿…è¦ï¼‰
    SKIPPED = "skipped"         # ãƒã‚§ãƒƒã‚¯ã‚¹ã‚­ãƒƒãƒ—

class EscalationLevel(str, Enum):
    """ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«"""
    INFO = "info"               # æƒ…å ±æä¾›ã®ã¿
    CONFIRMATION = "confirmation"  # ç¢ºèªãŒå¿…è¦
    DECISION = "decision"       # åˆ¤æ–­ãŒå¿…è¦
    URGENT = "urgent"           # ç·Šæ€¥å¯¾å¿œãŒå¿…è¦
```

### 21.4.2 ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹å®šç¾©

```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any

@dataclass
class SubTask:
    """
    åˆ†è§£ã•ã‚ŒãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯

    è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’åˆ†è§£ã—ãŸå˜ä½ã‚¿ã‚¹ã‚¯ã€‚
    """
    id: str
    name: str                           # ã‚¿ã‚¹ã‚¯åï¼ˆä¾‹: ã€Œä¼šè­°å®¤ã®ç©ºãç¢ºèªã€ï¼‰
    description: str                    # è©³ç´°èª¬æ˜
    action: str                         # å®Ÿè¡Œã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³åï¼ˆSYSTEM_CAPABILITIESã®ã‚­ãƒ¼ï¼‰
    params: Dict[str, Any] = field(default_factory=dict)  # ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

    # ä¾å­˜é–¢ä¿‚
    depends_on: List[str] = field(default_factory=list)   # ä¾å­˜ã™ã‚‹ã‚µãƒ–ã‚¿ã‚¹ã‚¯ID
    blocks: List[str] = field(default_factory=list)       # ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ã‚µãƒ–ã‚¿ã‚¹ã‚¯ID

    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    status: SubTaskStatus = SubTaskStatus.PENDING
    priority: ExecutionPriority = ExecutionPriority.NORMAL

    # å®Ÿè¡Œè¨­å®š
    is_optional: bool = False           # ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã‹ï¼ˆå¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼‰
    max_retries: int = 3                # æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
    timeout_seconds: int = 60           # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç§’æ•°
    recovery_strategy: RecoveryStrategy = RecoveryStrategy.RETRY

    # å®Ÿè¡Œçµæœ
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    retry_count: int = 0

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    @property
    def is_ready(self) -> bool:
        """å®Ÿè¡Œå¯èƒ½ãªçŠ¶æ…‹ã‹"""
        return self.status == SubTaskStatus.PENDING

    @property
    def is_terminal(self) -> bool:
        """çµ‚äº†çŠ¶æ…‹ã‹"""
        return self.status in (
            SubTaskStatus.COMPLETED,
            SubTaskStatus.FAILED,
            SubTaskStatus.SKIPPED,
            SubTaskStatus.ESCALATED,
        )


@dataclass
class ExecutionPlan:
    """
    å®Ÿè¡Œè¨ˆç”»

    ã‚µãƒ–ã‚¿ã‚¹ã‚¯ç¾¤ã®å®Ÿè¡Œé †åºã¨ä¾å­˜é–¢ä¿‚ã‚’å®šç¾©ã€‚
    """
    id: str
    name: str                           # è¨ˆç”»åï¼ˆä¾‹: ã€Œä¼šè­°å®¤äºˆç´„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã€ï¼‰
    description: str                    # è¨ˆç”»ã®èª¬æ˜
    original_request: str               # å…ƒã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

    # ã‚µãƒ–ã‚¿ã‚¹ã‚¯
    subtasks: List[SubTask] = field(default_factory=list)

    # å®Ÿè¡Œè¨­å®š
    parallel_execution: bool = True     # ä¸¦åˆ—å®Ÿè¡Œã‚’è¨±å¯ã™ã‚‹ã‹
    continue_on_failure: bool = False   # å¤±æ•—æ™‚ã‚‚ç¶šè¡Œã™ã‚‹ã‹

    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    status: SubTaskStatus = SubTaskStatus.PENDING
    current_step: int = 0               # ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—

    # å“è³ªãƒã‚§ãƒƒã‚¯è¨­å®š
    quality_checks_enabled: bool = True
    required_quality_level: float = 0.8  # å¿…è¦ãªå“è³ªã‚¹ã‚³ã‚¢ï¼ˆ0.0-1.0ï¼‰

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
    room_id: str = ""
    account_id: str = ""
    organization_id: str = ""

    @property
    def progress(self) -> float:
        """é€²æ—ç‡ï¼ˆ0.0-1.0ï¼‰"""
        if not self.subtasks:
            return 0.0
        completed = sum(1 for st in self.subtasks if st.is_terminal)
        return completed / len(self.subtasks)

    @property
    def completed_count(self) -> int:
        """å®Œäº†ã—ãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯æ•°"""
        return sum(1 for st in self.subtasks if st.status == SubTaskStatus.COMPLETED)

    @property
    def failed_count(self) -> int:
        """å¤±æ•—ã—ãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯æ•°"""
        return sum(1 for st in self.subtasks if st.status == SubTaskStatus.FAILED)

    def get_ready_tasks(self) -> List[SubTask]:
        """å®Ÿè¡Œå¯èƒ½ãªã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å–å¾—"""
        ready = []
        completed_ids = {
            st.id for st in self.subtasks
            if st.status in (SubTaskStatus.COMPLETED, SubTaskStatus.SKIPPED)
        }
        for st in self.subtasks:
            if st.is_ready and all(dep in completed_ids for dep in st.depends_on):
                ready.append(st)
        return ready


@dataclass
class ProgressReport:
    """
    é€²æ—ãƒ¬ãƒãƒ¼ãƒˆ

    å®Ÿè¡Œä¸­ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®é€²æ—çŠ¶æ³ã€‚
    """
    plan_id: str
    plan_name: str

    # é€²æ—
    total_subtasks: int
    completed_subtasks: int
    failed_subtasks: int
    in_progress_subtasks: int
    pending_subtasks: int

    # é€²æ—ç‡
    progress_percentage: float          # 0.0-100.0

    # ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    current_activity: str               # ç¾åœ¨å®Ÿè¡Œä¸­ã®å†…å®¹
    estimated_remaining_time: Optional[int] = None  # æ®‹ã‚Šæ™‚é–“ï¼ˆç§’ï¼‰

    # å•é¡Œ
    issues: List[str] = field(default_factory=list)

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    started_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    def to_user_message(self) -> str:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ"""
        progress_bar = self._generate_progress_bar()

        message = f"""ğŸ“Š é€²æ—çŠ¶æ³ã‚¦ãƒ«

{self.plan_name}
{progress_bar} {self.progress_percentage:.0f}%

{self.current_activity}"""

        if self.issues:
            message += f"\n\nâš ï¸ æ³¨æ„: {', '.join(self.issues)}"

        return message

    def _generate_progress_bar(self) -> str:
        """ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’ç”Ÿæˆ"""
        filled = int(self.progress_percentage / 10)
        empty = 10 - filled
        return "â–“" * filled + "â–‘" * empty


@dataclass
class QualityReport:
    """
    å“è³ªãƒã‚§ãƒƒã‚¯ãƒ¬ãƒãƒ¼ãƒˆ

    å®Ÿè¡Œçµæœã®å“è³ªæ¤œè¨¼çµæœã€‚
    """
    plan_id: str
    subtask_id: Optional[str] = None    # å€‹åˆ¥ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®å ´åˆ

    # ãƒã‚§ãƒƒã‚¯çµæœ
    overall_result: QualityCheckResult = QualityCheckResult.PASS
    quality_score: float = 1.0          # 0.0-1.0

    # è©³ç´°ãƒã‚§ãƒƒã‚¯
    checks: List[Dict[str, Any]] = field(default_factory=list)
    # [
    #   {"name": "ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§", "result": "pass", "score": 1.0},
    #   {"name": "æœŸé™ãƒã‚§ãƒƒã‚¯", "result": "warning", "score": 0.8, "message": "24æ™‚é–“ä»¥å†…"},
    # ]

    # å•é¡Œç‚¹
    issues: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    # æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    recommended_actions: List[str] = field(default_factory=list)

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    checked_at: datetime = field(default_factory=datetime.now)


@dataclass
class EscalationRequest:
    """
    ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

    è‡ªå‹•å‡¦ç†ã§ããªã„å ´åˆã«äººé–“ã«ç¢ºèªã‚’æ±‚ã‚ã‚‹ã€‚
    """
    id: str
    plan_id: str
    subtask_id: Optional[str] = None

    # ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å†…å®¹
    level: EscalationLevel = EscalationLevel.CONFIRMATION
    title: str = ""                     # ä»¶å
    description: str = ""               # è©³ç´°èª¬æ˜
    context: str = ""                   # èƒŒæ™¯ãƒ»çµŒç·¯

    # é¸æŠè‚¢ï¼ˆç¢ºèªãƒ»åˆ¤æ–­ã®å ´åˆï¼‰
    options: List[Dict[str, str]] = field(default_factory=list)
    # [
    #   {"id": "proceed", "label": "ç¶šè¡Œã™ã‚‹", "description": "..."},
    #   {"id": "abort", "label": "ä¸­æ­¢ã™ã‚‹", "description": "..."},
    # ]
    default_option: Optional[str] = None

    # æ¨å¥¨
    recommendation: Optional[str] = None  # ã‚½ã‚¦ãƒ«ãã‚“ã®æ¨å¥¨
    recommendation_reasoning: Optional[str] = None

    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    status: str = "pending"             # pending, responded, expired
    response: Optional[str] = None
    response_reasoning: Optional[str] = None

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    created_at: datetime = field(default_factory=datetime.now)
    expires_at: Optional[datetime] = None
    responded_at: Optional[datetime] = None

    # é€šçŸ¥æƒ…å ±
    notification_sent: bool = False
    notification_room_id: Optional[str] = None
    notification_message_id: Optional[str] = None

    def to_user_message(self) -> str:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ"""
        level_emoji = {
            EscalationLevel.INFO: "â„¹ï¸",
            EscalationLevel.CONFIRMATION: "ğŸ¤”",
            EscalationLevel.DECISION: "âš ï¸",
            EscalationLevel.URGENT: "ğŸš¨",
        }

        message = f"""{level_emoji.get(self.level, "â“")} {self.title}

{self.description}"""

        if self.context:
            message += f"\n\nğŸ“‹ çµŒç·¯:\n{self.context}"

        if self.recommendation:
            message += f"\n\nğŸ’¡ ã‚½ã‚¦ãƒ«ãã‚“ã®æ¨å¥¨: {self.recommendation}"
            if self.recommendation_reasoning:
                message += f"\n  ç†ç”±: {self.recommendation_reasoning}"

        if self.options:
            message += "\n\né¸æŠè‚¢:"
            for i, opt in enumerate(self.options, 1):
                message += f"\n{i}. {opt['label']}"
                if opt.get('description'):
                    message += f"\n   {opt['description']}"

        message += "\n\nç•ªå·ã§æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº"

        return message


@dataclass
class ExecutionResult:
    """
    å®Ÿè¡Œçµæœ

    ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“ã®å®Ÿè¡Œçµæœã€‚
    """
    plan_id: str
    plan_name: str
    original_request: str

    # çµæœ
    success: bool
    message: str                        # ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    # è©³ç´°
    completed_subtasks: List[str] = field(default_factory=list)  # å®Œäº†ã—ãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯å
    failed_subtasks: List[str] = field(default_factory=list)     # å¤±æ•—ã—ãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯å
    skipped_subtasks: List[str] = field(default_factory=list)    # ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯å

    # å“è³ª
    quality_score: float = 1.0
    quality_report: Optional[QualityReport] = None

    # ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    escalations: List[EscalationRequest] = field(default_factory=list)

    # å®Ÿè¡Œçµ±è¨ˆ
    total_execution_time_ms: int = 0
    retry_count: int = 0

    # æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ææ¡ˆ
    suggestions: List[str] = field(default_factory=list)

    # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    started_at: Optional[datetime] = None
    completed_at: datetime = field(default_factory=datetime.now)
```

---

## 21.5 ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°è¨­è¨ˆ

### 21.5.1 TaskDecomposerï¼ˆã‚¿ã‚¹ã‚¯åˆ†è§£å™¨ï¼‰

```python
# lib/brain/execution_excellence/decomposer.py

class TaskDecomposer:
    """
    ã‚¿ã‚¹ã‚¯åˆ†è§£å™¨

    è¤‡é›‘ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã™ã‚‹ã€‚
    """

    def __init__(
        self,
        capabilities: Dict[str, Dict],
        llm_client: Optional[Any] = None,
    ):
        self.capabilities = capabilities
        self.llm_client = llm_client

        # åˆ†è§£ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰
        self.decomposition_patterns = self._load_patterns()

    async def decompose(
        self,
        request: str,
        context: BrainContext,
    ) -> List[SubTask]:
        """
        ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã«åˆ†è§£

        Args:
            request: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            context: è„³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ãƒªã‚¹ãƒˆ
        """
        # 1. ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹åˆ†è§£ã‚’è©¦è¡Œ
        subtasks = self._rule_based_decompose(request)

        if subtasks:
            return subtasks

        # 2. LLMãƒ™ãƒ¼ã‚¹åˆ†è§£ï¼ˆè¤‡é›‘ãªã‚±ãƒ¼ã‚¹ï¼‰
        if self.llm_client:
            subtasks = await self._llm_based_decompose(request, context)

        return subtasks or self._create_single_task(request)

    def _rule_based_decompose(self, request: str) -> Optional[List[SubTask]]:
        """ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®åˆ†è§£"""
        for pattern in self.decomposition_patterns:
            if pattern.matches(request):
                return pattern.decompose(request)
        return None

    async def _llm_based_decompose(
        self,
        request: str,
        context: BrainContext,
    ) -> List[SubTask]:
        """LLMã‚’ä½¿ã£ãŸåˆ†è§£"""
        prompt = self._build_decomposition_prompt(request, context)
        response = await self.llm_client.generate(prompt)
        return self._parse_decomposition_response(response)
```

**åˆ†è§£ãƒ‘ã‚¿ãƒ¼ãƒ³ä¾‹:**

```python
DECOMPOSITION_PATTERNS = [
    # ä¼šè­°å®¤äºˆç´„ãƒ‘ã‚¿ãƒ¼ãƒ³
    DecompositionPattern(
        name="meeting_room_reservation",
        triggers=["ä¼šè­°å®¤", "äºˆç´„", "ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ«ãƒ¼ãƒ "],
        conditions=["æ—¥æ™‚æŒ‡å®š", "å‚åŠ è€…æŒ‡å®š"],
        subtasks=[
            SubTaskTemplate(
                name="ç©ºãç¢ºèª",
                action="check_room_availability",
                depends_on=[],
            ),
            SubTaskTemplate(
                name="äºˆç´„å®Ÿè¡Œ",
                action="reserve_meeting_room",
                depends_on=["ç©ºãç¢ºèª"],
            ),
            SubTaskTemplate(
                name="æ‹›å¾…é€ä¿¡",
                action="send_calendar_invite",
                depends_on=["äºˆç´„å®Ÿè¡Œ"],
                is_optional=True,
            ),
        ],
    ),

    # ã‚¿ã‚¹ã‚¯ä¸€æ‹¬å®Œäº†ãƒ‘ã‚¿ãƒ¼ãƒ³
    DecompositionPattern(
        name="bulk_task_completion",
        triggers=["ã‚¿ã‚¹ã‚¯", "å®Œäº†", "ä¸€æ‹¬", "ã¾ã¨ã‚ã¦"],
        conditions=["è¤‡æ•°ã‚¿ã‚¹ã‚¯æŒ‡å®š"],
        subtasks=[
            SubTaskTemplate(
                name="ã‚¿ã‚¹ã‚¯å–å¾—",
                action="chatwork_task_search",
                depends_on=[],
            ),
            SubTaskTemplate(
                name="ä¸€æ‹¬å®Œäº†",
                action="chatwork_task_complete_bulk",
                depends_on=["ã‚¿ã‚¹ã‚¯å–å¾—"],
            ),
            SubTaskTemplate(
                name="å®Œäº†å ±å‘Š",
                action="generate_completion_report",
                depends_on=["ä¸€æ‹¬å®Œäº†"],
            ),
        ],
    ),
]
```

### 21.5.2 ExecutionPlannerï¼ˆå®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆï¼‰

```python
# lib/brain/execution_excellence/planner.py

class ExecutionPlanner:
    """
    å®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆ

    ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ã‚’è§£æã—ã€æœ€é©ãªå®Ÿè¡Œé †åºã‚’æ±ºå®šã™ã‚‹ã€‚
    """

    def create_plan(
        self,
        subtasks: List[SubTask],
        request: str,
        context: BrainContext,
    ) -> ExecutionPlan:
        """
        å®Ÿè¡Œè¨ˆç”»ã‚’ä½œæˆ

        Args:
            subtasks: ã‚µãƒ–ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
            request: å…ƒã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            context: è„³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            å®Ÿè¡Œè¨ˆç”»
        """
        # 1. ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰
        dependency_graph = self._build_dependency_graph(subtasks)

        # 2. ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆï¼ˆå¾ªç’°ä¾å­˜ãƒã‚§ãƒƒã‚¯å«ã‚€ï¼‰
        sorted_tasks = self._topological_sort(dependency_graph)

        # 3. ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç‰¹å®š
        parallel_groups = self._identify_parallel_groups(sorted_tasks, dependency_graph)

        # 4. å®Ÿè¡Œè¨ˆç”»ã‚’æ§‹ç¯‰
        plan = ExecutionPlan(
            id=str(uuid.uuid4()),
            name=self._generate_plan_name(request),
            description=f"ã€Œ{request}ã€ã®å®Ÿè¡Œè¨ˆç”»",
            original_request=request,
            subtasks=sorted_tasks,
            parallel_execution=len(parallel_groups) > 1,
            room_id=context.room_id,
            account_id=context.sender_account_id,
            organization_id=context.organization_id,
        )

        return plan

    def _build_dependency_graph(
        self,
        subtasks: List[SubTask],
    ) -> Dict[str, List[str]]:
        """ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰"""
        graph = {st.id: st.depends_on for st in subtasks}
        return graph

    def _topological_sort(
        self,
        graph: Dict[str, List[str]],
    ) -> List[SubTask]:
        """ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ"""
        # ã‚«ãƒ¼ãƒ³ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨
        in_degree = {node: 0 for node in graph}
        for deps in graph.values():
            for dep in deps:
                in_degree[dep] = in_degree.get(dep, 0) + 1

        queue = [node for node, degree in in_degree.items() if degree == 0]
        result = []

        while queue:
            node = queue.pop(0)
            result.append(node)
            for neighbor, deps in graph.items():
                if node in deps:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)

        if len(result) != len(graph):
            raise ValueError("å¾ªç’°ä¾å­˜ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")

        return result
```

### 21.5.3 WorkflowExecutorï¼ˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œï¼‰

```python
# lib/brain/execution_excellence/executor.py

class WorkflowExecutor:
    """
    ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ

    ExecutionPlanã«å¾“ã£ã¦ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
    """

    def __init__(
        self,
        handlers: Dict[str, Callable],
        progress_tracker: ProgressTracker,
        quality_checker: QualityChecker,
        exception_handler: ExceptionHandler,
        escalation_manager: EscalationManager,
    ):
        self.handlers = handlers
        self.progress_tracker = progress_tracker
        self.quality_checker = quality_checker
        self.exception_handler = exception_handler
        self.escalation_manager = escalation_manager

    async def execute(
        self,
        plan: ExecutionPlan,
        context: BrainContext,
    ) -> ExecutionResult:
        """
        å®Ÿè¡Œè¨ˆç”»ã‚’å®Ÿè¡Œ

        Args:
            plan: å®Ÿè¡Œè¨ˆç”»
            context: è„³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            å®Ÿè¡Œçµæœ
        """
        plan.status = SubTaskStatus.IN_PROGRESS
        plan.started_at = datetime.now()

        try:
            # 1. å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡/ä¸¦åˆ—å®Ÿè¡Œ
            while not self._is_plan_complete(plan):
                ready_tasks = plan.get_ready_tasks()

                if not ready_tasks:
                    # å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ãŒãªã„ = ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã¾ãŸã¯å…¨ã¦å®Œäº†
                    if not self._is_plan_complete(plan):
                        raise ExecutionError("å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯?ï¼‰")
                    break

                # ä¸¦åˆ—å®Ÿè¡Œ
                if plan.parallel_execution and len(ready_tasks) > 1:
                    results = await asyncio.gather(
                        *[self._execute_subtask(st, plan, context) for st in ready_tasks],
                        return_exceptions=True,
                    )
                else:
                    # é †æ¬¡å®Ÿè¡Œ
                    for task in ready_tasks:
                        await self._execute_subtask(task, plan, context)

                # é€²æ—æ›´æ–°
                await self.progress_tracker.update(plan)

            # 2. å“è³ªãƒã‚§ãƒƒã‚¯
            if plan.quality_checks_enabled:
                quality_report = await self.quality_checker.check_plan(plan)
                if quality_report.overall_result == QualityCheckResult.FAIL:
                    # å“è³ªä¸åˆæ ¼ â†’ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    escalation = await self.escalation_manager.create_quality_escalation(
                        plan, quality_report
                    )
                    return self._create_result(plan, escalation=escalation)

            # 3. å®Œäº†
            plan.status = SubTaskStatus.COMPLETED
            plan.completed_at = datetime.now()

            return self._create_result(plan)

        except Exception as e:
            # ä¾‹å¤–å‡¦ç†
            recovery_result = await self.exception_handler.handle(e, plan, context)
            return self._create_result(plan, error=recovery_result)

    async def _execute_subtask(
        self,
        subtask: SubTask,
        plan: ExecutionPlan,
        context: BrainContext,
    ) -> bool:
        """ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        subtask.status = SubTaskStatus.IN_PROGRESS
        subtask.started_at = datetime.now()

        try:
            # ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å–å¾—
            handler = self.handlers.get(subtask.action)
            if not handler:
                raise HandlerNotFoundError(f"ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {subtask.action}")

            # å®Ÿè¡Œï¼ˆãƒªãƒˆãƒ©ã‚¤ã‚ã‚Šï¼‰
            for attempt in range(subtask.max_retries):
                try:
                    result = await asyncio.wait_for(
                        handler(
                            params=subtask.params,
                            room_id=plan.room_id,
                            account_id=plan.account_id,
                            sender_name=context.sender_name,
                            context=context,
                        ),
                        timeout=subtask.timeout_seconds,
                    )

                    if result.success:
                        subtask.status = SubTaskStatus.COMPLETED
                        subtask.result = result.data
                        subtask.completed_at = datetime.now()
                        return True

                    subtask.retry_count += 1

                except asyncio.TimeoutError:
                    subtask.retry_count += 1
                    if attempt == subtask.max_retries - 1:
                        raise

            # ãƒªãƒˆãƒ©ã‚¤ä¸Šé™åˆ°é”
            subtask.status = SubTaskStatus.FAILED
            subtask.error = "æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’è¶…ãˆã¾ã—ãŸ"
            return False

        except Exception as e:
            subtask.status = SubTaskStatus.FAILED
            subtask.error = str(e)

            # ãƒªã‚«ãƒãƒªãƒ¼æˆ¦ç•¥ã«åŸºã¥ãå‡¦ç†
            return await self._apply_recovery_strategy(subtask, plan, context, e)

    async def _apply_recovery_strategy(
        self,
        subtask: SubTask,
        plan: ExecutionPlan,
        context: BrainContext,
        error: Exception,
    ) -> bool:
        """ãƒªã‚«ãƒãƒªãƒ¼æˆ¦ç•¥ã‚’é©ç”¨"""
        strategy = subtask.recovery_strategy

        if strategy == RecoveryStrategy.SKIP and subtask.is_optional:
            subtask.status = SubTaskStatus.SKIPPED
            return True

        elif strategy == RecoveryStrategy.ESCALATE:
            escalation = await self.escalation_manager.create_task_escalation(
                subtask, plan, error
            )
            subtask.status = SubTaskStatus.ESCALATED
            return False

        elif strategy == RecoveryStrategy.ABORT:
            plan.status = SubTaskStatus.FAILED
            raise ExecutionError(f"ã‚¿ã‚¹ã‚¯å¤±æ•—ã«ã‚ˆã‚Šä¸­æ­¢: {subtask.name}")

        # RETRY, ALTERNATIVEã¯_execute_subtaskå†…ã§å‡¦ç†æ¸ˆã¿
        return False
```

### 21.5.4 ProgressTrackerï¼ˆé€²æ—è¿½è·¡ï¼‰

```python
# lib/brain/execution_excellence/progress.py

class ProgressTracker:
    """
    é€²æ—è¿½è·¡

    å®Ÿè¡Œä¸­ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®é€²æ—ã‚’è¿½è·¡ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å ±å‘Šã™ã‚‹ã€‚
    """

    def __init__(
        self,
        notification_threshold: float = 0.25,  # 25%ã”ã¨ã«é€šçŸ¥
        stale_threshold_seconds: int = 60,      # 60ç§’å‹•ããŒãªã‘ã‚Œã°é€šçŸ¥
    ):
        self.notification_threshold = notification_threshold
        self.stale_threshold_seconds = stale_threshold_seconds
        self._last_notified_progress: Dict[str, float] = {}
        self._last_activity_time: Dict[str, datetime] = {}

    async def update(self, plan: ExecutionPlan) -> Optional[ProgressReport]:
        """
        é€²æ—ã‚’æ›´æ–°

        å¿…è¦ã«å¿œã˜ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€²æ—ã‚’é€šçŸ¥ã™ã‚‹ã€‚
        """
        report = self._create_report(plan)

        # é€šçŸ¥ãŒå¿…è¦ã‹åˆ¤å®š
        should_notify = self._should_notify(plan.id, report)

        if should_notify:
            self._last_notified_progress[plan.id] = report.progress_percentage
            self._last_activity_time[plan.id] = datetime.now()
            return report

        return None

    def _create_report(self, plan: ExecutionPlan) -> ProgressReport:
        """é€²æ—ãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆ"""
        in_progress = sum(
            1 for st in plan.subtasks if st.status == SubTaskStatus.IN_PROGRESS
        )
        pending = sum(
            1 for st in plan.subtasks if st.status == SubTaskStatus.PENDING
        )

        current_activity = "å‡¦ç†ä¸­..."
        in_progress_tasks = [
            st for st in plan.subtasks if st.status == SubTaskStatus.IN_PROGRESS
        ]
        if in_progress_tasks:
            current_activity = f"ã€Œ{in_progress_tasks[0].name}ã€ã‚’å®Ÿè¡Œä¸­"

        issues = []
        failed_tasks = [
            st for st in plan.subtasks if st.status == SubTaskStatus.FAILED
        ]
        if failed_tasks:
            issues.append(f"{len(failed_tasks)}å€‹ã®ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—")

        return ProgressReport(
            plan_id=plan.id,
            plan_name=plan.name,
            total_subtasks=len(plan.subtasks),
            completed_subtasks=plan.completed_count,
            failed_subtasks=plan.failed_count,
            in_progress_subtasks=in_progress,
            pending_subtasks=pending,
            progress_percentage=plan.progress * 100,
            current_activity=current_activity,
            issues=issues,
        )

    def _should_notify(self, plan_id: str, report: ProgressReport) -> bool:
        """é€šçŸ¥ã™ã¹ãã‹åˆ¤å®š"""
        last_progress = self._last_notified_progress.get(plan_id, 0)
        progress_diff = report.progress_percentage - last_progress

        # é€²æ—ãŒé–¾å€¤ã‚’è¶…ãˆãŸ
        if progress_diff >= self.notification_threshold * 100:
            return True

        # é•·æ™‚é–“å‹•ããŒãªã„
        last_activity = self._last_activity_time.get(plan_id)
        if last_activity:
            elapsed = (datetime.now() - last_activity).total_seconds()
            if elapsed >= self.stale_threshold_seconds:
                return True

        # å®Œäº†ã¾ãŸã¯å¤±æ•—
        if report.progress_percentage >= 100 or report.failed_subtasks > 0:
            return True

        return False
```

### 21.5.5 QualityCheckerï¼ˆå“è³ªãƒã‚§ãƒƒã‚«ãƒ¼ï¼‰

```python
# lib/brain/execution_excellence/quality.py

class QualityChecker:
    """
    å“è³ªãƒã‚§ãƒƒã‚«ãƒ¼

    å®Ÿè¡Œçµæœã®å“è³ªã‚’æ¤œè¨¼ã™ã‚‹ã€‚
    """

    def __init__(self, checks: Optional[List[QualityCheck]] = None):
        self.checks = checks or self._default_checks()

    async def check_plan(self, plan: ExecutionPlan) -> QualityReport:
        """
        å®Ÿè¡Œè¨ˆç”»å…¨ä½“ã®å“è³ªã‚’ãƒã‚§ãƒƒã‚¯
        """
        check_results = []
        issues = []
        warnings = []

        for check in self.checks:
            result = await check.execute(plan)
            check_results.append({
                "name": check.name,
                "result": result.status.value,
                "score": result.score,
                "message": result.message,
            })

            if result.status == QualityCheckResult.FAIL:
                issues.append(f"{check.name}: {result.message}")
            elif result.status == QualityCheckResult.WARNING:
                warnings.append(f"{check.name}: {result.message}")

        # ç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
        total_score = sum(r["score"] for r in check_results) / len(check_results)

        # ç·åˆçµæœåˆ¤å®š
        if any(r["result"] == "fail" for r in check_results):
            overall_result = QualityCheckResult.FAIL
        elif any(r["result"] == "warning" for r in check_results):
            overall_result = QualityCheckResult.WARNING
        else:
            overall_result = QualityCheckResult.PASS

        return QualityReport(
            plan_id=plan.id,
            overall_result=overall_result,
            quality_score=total_score,
            checks=check_results,
            issues=issues,
            warnings=warnings,
        )

    def _default_checks(self) -> List[QualityCheck]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å“è³ªãƒã‚§ãƒƒã‚¯"""
        return [
            CompletionRateCheck(),      # å®Œäº†ç‡ãƒã‚§ãƒƒã‚¯
            ErrorRateCheck(),           # ã‚¨ãƒ©ãƒ¼ç‡ãƒã‚§ãƒƒã‚¯
            ExecutionTimeCheck(),       # å®Ÿè¡Œæ™‚é–“ãƒã‚§ãƒƒã‚¯
            DataIntegrityCheck(),       # ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        ]
```

### 21.5.6 ExceptionHandlerï¼ˆä¾‹å¤–å‡¦ç†ï¼‰

```python
# lib/brain/execution_excellence/exception_handler.py

class ExceptionHandler:
    """
    ä¾‹å¤–å‡¦ç†

    å®Ÿè¡Œä¸­ã®ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ã€é©åˆ‡ãªãƒªã‚«ãƒãƒªãƒ¼ã‚’è¡Œã†ã€‚
    """

    async def handle(
        self,
        error: Exception,
        plan: ExecutionPlan,
        context: BrainContext,
    ) -> RecoveryResult:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†

        Args:
            error: ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼
            plan: å®Ÿè¡Œè¨ˆç”»
            context: è„³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            ãƒªã‚«ãƒãƒªãƒ¼çµæœ
        """
        error_type = type(error).__name__

        # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†
        if error_type in TRANSIENT_ERRORS:
            # ä¸€æ™‚çš„ã‚¨ãƒ©ãƒ¼ â†’ ãƒªãƒˆãƒ©ã‚¤
            return await self._retry_recovery(error, plan)

        elif error_type in PERMISSION_ERRORS:
            # æ¨©é™ã‚¨ãƒ©ãƒ¼ â†’ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            return await self._escalate_permission_error(error, plan, context)

        elif error_type in DATA_ERRORS:
            # ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼ â†’ ä»£æ›¿æ¡ˆæç¤º
            return await self._suggest_alternative(error, plan, context)

        else:
            # æœªçŸ¥ã®ã‚¨ãƒ©ãƒ¼ â†’ ãƒ­ã‚°è¨˜éŒ²ã—ã¦ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            logger.error(f"Unknown error in execution: {error}", exc_info=True)
            return await self._escalate_unknown_error(error, plan, context)

    async def _retry_recovery(
        self,
        error: Exception,
        plan: ExecutionPlan,
    ) -> RecoveryResult:
        """ãƒªãƒˆãƒ©ã‚¤ã«ã‚ˆã‚‹ãƒªã‚«ãƒãƒªãƒ¼"""
        # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§ãƒªãƒˆãƒ©ã‚¤
        delay = 2 ** plan.current_step  # 1, 2, 4, 8...ç§’
        await asyncio.sleep(min(delay, 30))  # æœ€å¤§30ç§’

        return RecoveryResult(
            strategy=RecoveryStrategy.RETRY,
            success=True,
            message="ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™",
        )

    async def _suggest_alternative(
        self,
        error: Exception,
        plan: ExecutionPlan,
        context: BrainContext,
    ) -> RecoveryResult:
        """ä»£æ›¿æ¡ˆã‚’ææ¡ˆ"""
        alternatives = self._find_alternatives(plan, error)

        if alternatives:
            return RecoveryResult(
                strategy=RecoveryStrategy.ALTERNATIVE,
                success=True,
                message=f"ä»£æ›¿æ¡ˆãŒã‚ã‚‹ã‚¦ãƒ«: {alternatives[0]}",
                alternatives=alternatives,
            )

        return RecoveryResult(
            strategy=RecoveryStrategy.ESCALATE,
            success=False,
            message="ä»£æ›¿æ¡ˆãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‚¦ãƒ«...",
        )
```

### 21.5.7 EscalationManagerï¼ˆã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ï¼‰

```python
# lib/brain/execution_excellence/escalation.py

class EscalationManager:
    """
    ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†

    è‡ªå‹•å‡¦ç†ã§ããªã„å•é¡Œã‚’äººé–“ã«ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã€‚
    """

    def __init__(
        self,
        chatwork_client: Any,
        default_timeout_minutes: int = 30,
    ):
        self.chatwork_client = chatwork_client
        self.default_timeout_minutes = default_timeout_minutes
        self._pending_escalations: Dict[str, EscalationRequest] = {}

    async def create_task_escalation(
        self,
        subtask: SubTask,
        plan: ExecutionPlan,
        error: Exception,
    ) -> EscalationRequest:
        """ã‚¿ã‚¹ã‚¯å¤±æ•—ã®ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ"""
        escalation = EscalationRequest(
            id=str(uuid.uuid4()),
            plan_id=plan.id,
            subtask_id=subtask.id,
            level=EscalationLevel.DECISION,
            title=f"ã€Œ{subtask.name}ã€ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ",
            description=f"ã‚¨ãƒ©ãƒ¼å†…å®¹: {str(error)}",
            context=f"ã€Œ{plan.original_request}ã€ã®ä¸€éƒ¨ã¨ã—ã¦å®Ÿè¡Œä¸­ã§ã—ãŸ",
            options=[
                {"id": "retry", "label": "ãƒªãƒˆãƒ©ã‚¤", "description": "ã‚‚ã†ä¸€åº¦è©¦ã—ã¾ã™"},
                {"id": "skip", "label": "ã‚¹ã‚­ãƒƒãƒ—", "description": "ã“ã®ã‚¿ã‚¹ã‚¯ã‚’é£›ã°ã—ã¦ç¶šè¡Œ"},
                {"id": "abort", "label": "ä¸­æ­¢", "description": "å…¨ä½“ã®å‡¦ç†ã‚’ä¸­æ­¢"},
            ],
            recommendation="retry",
            recommendation_reasoning="ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™",
        )

        # é€šçŸ¥é€ä¿¡
        await self._send_notification(escalation, plan.room_id)

        self._pending_escalations[escalation.id] = escalation

        return escalation

    async def create_quality_escalation(
        self,
        plan: ExecutionPlan,
        quality_report: QualityReport,
    ) -> EscalationRequest:
        """å“è³ªå•é¡Œã®ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ"""
        escalation = EscalationRequest(
            id=str(uuid.uuid4()),
            plan_id=plan.id,
            level=EscalationLevel.CONFIRMATION,
            title="å“è³ªãƒã‚§ãƒƒã‚¯ã§å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ",
            description=f"å•é¡Œç‚¹: {', '.join(quality_report.issues)}",
            context=f"ã€Œ{plan.original_request}ã€ã®å®Ÿè¡Œçµæœã§ã™",
            options=[
                {"id": "accept", "label": "ãã®ã¾ã¾å®Œäº†", "description": "å•é¡Œã‚’è¨±å®¹ã—ã¦å®Œäº†"},
                {"id": "retry", "label": "ã‚„ã‚Šç›´ã—", "description": "æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—"},
                {"id": "manual", "label": "æ‰‹å‹•å¯¾å¿œ", "description": "è‡ªåˆ†ã§å¯¾å¿œã™ã‚‹"},
            ],
            recommendation="accept" if quality_report.quality_score > 0.7 else "manual",
        )

        await self._send_notification(escalation, plan.room_id)

        self._pending_escalations[escalation.id] = escalation

        return escalation

    async def process_response(
        self,
        escalation_id: str,
        response: str,
        reasoning: Optional[str] = None,
    ) -> bool:
        """ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã®å¿œç­”ã‚’å‡¦ç†"""
        escalation = self._pending_escalations.get(escalation_id)
        if not escalation:
            return False

        escalation.status = "responded"
        escalation.response = response
        escalation.response_reasoning = reasoning
        escalation.responded_at = datetime.now()

        return True

    async def _send_notification(
        self,
        escalation: EscalationRequest,
        room_id: str,
    ) -> None:
        """é€šçŸ¥ã‚’é€ä¿¡"""
        message = escalation.to_user_message()

        result = await self.chatwork_client.send_message(
            room_id=room_id,
            body=message,
        )

        escalation.notification_sent = True
        escalation.notification_room_id = room_id
        escalation.notification_message_id = result.get("message_id")
```

---

## 21.6 çµ±åˆè¨­è¨ˆ

### 21.6.1 ExecutionExcellenceçµ±åˆã‚¯ãƒ©ã‚¹

```python
# lib/brain/execution_excellence/__init__.py

class ExecutionExcellence:
    """
    å®Ÿè¡ŒåŠ›å¼·åŒ–ã®çµ±åˆã‚¯ãƒ©ã‚¹

    TaskDecomposerã€ExecutionPlannerã€WorkflowExecutorã€
    ãŠã‚ˆã³ã‚µãƒãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’çµ±åˆã™ã‚‹ã€‚
    """

    def __init__(
        self,
        pool,
        org_id: str,
        handlers: Dict[str, Callable],
        capabilities: Dict[str, Dict],
        chatwork_client: Optional[Any] = None,
        llm_client: Optional[Any] = None,
    ):
        self.pool = pool
        self.org_id = org_id

        # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ–
        self.decomposer = TaskDecomposer(capabilities, llm_client)
        self.planner = ExecutionPlanner()
        self.progress_tracker = ProgressTracker()
        self.quality_checker = QualityChecker()
        self.exception_handler = ExceptionHandler()
        self.escalation_manager = EscalationManager(chatwork_client)

        self.executor = WorkflowExecutor(
            handlers=handlers,
            progress_tracker=self.progress_tracker,
            quality_checker=self.quality_checker,
            exception_handler=self.exception_handler,
            escalation_manager=self.escalation_manager,
        )

    async def execute_request(
        self,
        request: str,
        context: BrainContext,
    ) -> ExecutionResult:
        """
        ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å®Ÿè¡Œ

        Args:
            request: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            context: è„³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            å®Ÿè¡Œçµæœ
        """
        # 1. ã‚¿ã‚¹ã‚¯åˆ†è§£
        subtasks = await self.decomposer.decompose(request, context)

        if len(subtasks) == 1:
            # å˜ä¸€ã‚¿ã‚¹ã‚¯ã®å ´åˆã¯å¾“æ¥ã®å®Ÿè¡Œå±¤ã‚’ä½¿ç”¨
            return await self._execute_single_task(subtasks[0], context)

        # 2. å®Ÿè¡Œè¨ˆç”»ç«‹æ¡ˆ
        plan = self.planner.create_plan(subtasks, request, context)

        # 3. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
        result = await self.executor.execute(plan, context)

        # 4. å®Ÿè¡Œçµæœã‚’è¨˜éŒ²ï¼ˆå­¦ç¿’ç”¨ï¼‰
        await self._log_execution(plan, result)

        return result

    def should_use_workflow(self, request: str, context: BrainContext) -> bool:
        """
        ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚’ä½¿ã†ã¹ãã‹åˆ¤å®š

        è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å ´åˆã¯True
        """
        # è¤‡æ•°ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¤ºå”†ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        multi_action_keywords = [
            "ã—ã¦ã€", "ã—ãŸå¾Œ", "ã—ã¦ã‹ã‚‰",
            "ã¨ã€", "ãã‚Œã‹ã‚‰", "ãã®å¾Œ",
            "ä¸€æ‹¬", "ã¾ã¨ã‚ã¦", "å…¨éƒ¨",
        ]

        for keyword in multi_action_keywords:
            if keyword in request:
                return True

        return False
```

### 21.6.2 è„³ã¸ã®çµ±åˆ

```python
# lib/brain/core.py ã¸ã®è¿½åŠ 

class SoulkunBrain:
    def __init__(self, ...):
        # ... æ—¢å­˜ã®åˆæœŸåŒ– ...

        # Phase 2L: ExecutionExcellence
        self.execution_excellence = self._init_execution_excellence()

    def _init_execution_excellence(self) -> Optional[ExecutionExcellence]:
        """ExecutionExcellenceã‚’åˆæœŸåŒ–"""
        if not is_feature_enabled("ENABLE_EXECUTION_EXCELLENCE"):
            return None

        return ExecutionExcellence(
            pool=self.pool,
            org_id=self.org_id,
            handlers=self.handlers,
            capabilities=self.capabilities,
            chatwork_client=self.chatwork_client,
            llm_client=self.llm_client,
        )

    async def _execute(
        self,
        decision: DecisionResult,
        context: BrainContext,
        room_id: str,
        account_id: str,
        sender_name: str,
    ) -> HandlerResult:
        """
        å®Ÿè¡Œå±¤ - åˆ¤æ–­çµæœã‚’å®Ÿè¡Œ
        """
        # Phase 2L: è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ExecutionExcellenceã‚’ä½¿ç”¨
        if self.execution_excellence:
            original_message = context.recent_conversation[-1].content if context.recent_conversation else ""

            if self.execution_excellence.should_use_workflow(original_message, context):
                result = await self.execution_excellence.execute_request(
                    request=original_message,
                    context=context,
                )
                return HandlerResult(
                    success=result.success,
                    message=result.message,
                    suggestions=result.suggestions,
                )

        # å¾“æ¥ã®å®Ÿè¡Œãƒ•ãƒ­ãƒ¼
        return await self.execution_layer.execute(
            decision=decision,
            context=context,
            room_id=room_id,
            account_id=account_id,
            sender_name=sender_name,
        )
```

---

## 21.7 DBè¨­è¨ˆ

### 21.7.1 æ–°è¦ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
-- å®Ÿè¡Œè¨ˆç”»ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE execution_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id),
    room_id VARCHAR(50) NOT NULL,
    account_id VARCHAR(50) NOT NULL,

    name VARCHAR(200) NOT NULL,
    description TEXT,
    original_request TEXT NOT NULL,

    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    progress DECIMAL(5, 2) DEFAULT 0.00,

    parallel_execution BOOLEAN DEFAULT TRUE,
    continue_on_failure BOOLEAN DEFAULT FALSE,
    quality_checks_enabled BOOLEAN DEFAULT TRUE,
    required_quality_level DECIMAL(3, 2) DEFAULT 0.80,

    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    CONSTRAINT fk_organization
        FOREIGN KEY (organization_id)
        REFERENCES organizations(id) ON DELETE CASCADE
);

-- ã‚µãƒ–ã‚¿ã‚¹ã‚¯ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE execution_subtasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plan_id UUID NOT NULL REFERENCES execution_plans(id) ON DELETE CASCADE,
    organization_id UUID NOT NULL,

    name VARCHAR(200) NOT NULL,
    description TEXT,
    action VARCHAR(100) NOT NULL,
    params JSONB DEFAULT '{}',

    depends_on TEXT[] DEFAULT '{}',
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    priority VARCHAR(20) DEFAULT 'normal',

    is_optional BOOLEAN DEFAULT FALSE,
    max_retries INTEGER DEFAULT 3,
    timeout_seconds INTEGER DEFAULT 60,
    recovery_strategy VARCHAR(20) DEFAULT 'retry',

    result JSONB,
    error TEXT,
    retry_count INTEGER DEFAULT 0,

    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    CONSTRAINT fk_plan
        FOREIGN KEY (plan_id)
        REFERENCES execution_plans(id) ON DELETE CASCADE
);

-- ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE execution_escalations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    plan_id UUID NOT NULL REFERENCES execution_plans(id),
    subtask_id UUID REFERENCES execution_subtasks(id),
    organization_id UUID NOT NULL,

    level VARCHAR(20) NOT NULL DEFAULT 'confirmation',
    title VARCHAR(300) NOT NULL,
    description TEXT,
    context TEXT,

    options JSONB DEFAULT '[]',
    default_option VARCHAR(50),
    recommendation VARCHAR(50),
    recommendation_reasoning TEXT,

    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    response VARCHAR(50),
    response_reasoning TEXT,

    expires_at TIMESTAMP WITH TIME ZONE,
    responded_at TIMESTAMP WITH TIME ZONE,

    notification_sent BOOLEAN DEFAULT FALSE,
    notification_room_id VARCHAR(50),
    notification_message_id VARCHAR(50),

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    CONSTRAINT fk_plan
        FOREIGN KEY (plan_id)
        REFERENCES execution_plans(id) ON DELETE CASCADE
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_execution_plans_org_status ON execution_plans(organization_id, status);
CREATE INDEX idx_execution_plans_room ON execution_plans(room_id, created_at DESC);
CREATE INDEX idx_execution_subtasks_plan ON execution_subtasks(plan_id);
CREATE INDEX idx_execution_subtasks_status ON execution_subtasks(status);
CREATE INDEX idx_execution_escalations_plan ON execution_escalations(plan_id);
CREATE INDEX idx_execution_escalations_status ON execution_escalations(status);
```

---

## 21.8 Feature Flags

```python
# lib/feature_flags.py ã«è¿½åŠ 

EXECUTION_EXCELLENCE_FLAGS = {
    # ãƒ¡ã‚¤ãƒ³æ©Ÿèƒ½ãƒ•ãƒ©ã‚°
    "ENABLE_EXECUTION_EXCELLENCE": {
        "default": False,
        "description": "Phase 2L: å®Ÿè¡ŒåŠ›å¼·åŒ–ã‚’æœ‰åŠ¹åŒ–",
    },

    # ã‚µãƒ–æ©Ÿèƒ½ãƒ•ãƒ©ã‚°
    "ENABLE_TASK_DECOMPOSITION": {
        "default": True,
        "description": "ã‚¿ã‚¹ã‚¯è‡ªå‹•åˆ†è§£ã‚’æœ‰åŠ¹åŒ–",
        "depends_on": "ENABLE_EXECUTION_EXCELLENCE",
    },
    "ENABLE_PARALLEL_EXECUTION": {
        "default": True,
        "description": "ä¸¦åˆ—å®Ÿè¡Œã‚’æœ‰åŠ¹åŒ–",
        "depends_on": "ENABLE_EXECUTION_EXCELLENCE",
    },
    "ENABLE_QUALITY_CHECKS": {
        "default": True,
        "description": "å“è³ªãƒã‚§ãƒƒã‚¯ã‚’æœ‰åŠ¹åŒ–",
        "depends_on": "ENABLE_EXECUTION_EXCELLENCE",
    },
    "ENABLE_AUTO_ESCALATION": {
        "default": True,
        "description": "è‡ªå‹•ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–",
        "depends_on": "ENABLE_EXECUTION_EXCELLENCE",
    },

    # LLMä½¿ç”¨ãƒ•ãƒ©ã‚°
    "ENABLE_LLM_DECOMPOSITION": {
        "default": False,
        "description": "LLMãƒ™ãƒ¼ã‚¹ã®ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚’æœ‰åŠ¹åŒ–ï¼ˆã‚³ã‚¹ãƒˆæ³¨æ„ï¼‰",
        "depends_on": "ENABLE_TASK_DECOMPOSITION",
    },
}
```

---

## 21.9 ãƒ†ã‚¹ãƒˆè¨ˆç”»

### 21.9.1 ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

```python
# tests/test_execution_excellence.py

class TestTaskDecomposer:
    """TaskDecomposerã®ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_simple_request_not_decomposed(self):
        """å˜ç´”ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯åˆ†è§£ã•ã‚Œãªã„"""
        decomposer = TaskDecomposer(CAPABILITIES)
        subtasks = await decomposer.decompose(
            "è‡ªåˆ†ã®ã‚¿ã‚¹ã‚¯æ•™ãˆã¦",
            mock_context(),
        )
        assert len(subtasks) == 1

    @pytest.mark.asyncio
    async def test_complex_request_decomposed(self):
        """è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯åˆ†è§£ã•ã‚Œã‚‹"""
        decomposer = TaskDecomposer(CAPABILITIES)
        subtasks = await decomposer.decompose(
            "ä¼šè­°å®¤Aã‚’æ˜æ—¥14æ™‚ã§äºˆç´„ã—ã¦ã€å‚åŠ è€…ã«æ‹›å¾…é€ã£ã¦",
            mock_context(),
        )
        assert len(subtasks) >= 2


class TestWorkflowExecutor:
    """WorkflowExecutorã®ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_sequential_execution(self):
        """ä¾å­˜ã‚¿ã‚¹ã‚¯ãŒé †æ¬¡å®Ÿè¡Œã•ã‚Œã‚‹"""
        ...

    @pytest.mark.asyncio
    async def test_parallel_execution(self):
        """ç‹¬ç«‹ã‚¿ã‚¹ã‚¯ãŒä¸¦åˆ—å®Ÿè¡Œã•ã‚Œã‚‹"""
        ...

    @pytest.mark.asyncio
    async def test_failure_recovery(self):
        """å¤±æ•—æ™‚ã«ãƒªã‚«ãƒãƒªãƒ¼ã•ã‚Œã‚‹"""
        ...

    @pytest.mark.asyncio
    async def test_escalation_on_unrecoverable_error(self):
        """å›å¾©ä¸èƒ½ã‚¨ãƒ©ãƒ¼ã§ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã•ã‚Œã‚‹"""
        ...
```

### 21.9.2 çµ±åˆãƒ†ã‚¹ãƒˆ

```python
class TestExecutionExcellenceIntegration:
    """çµ±åˆãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_end_to_end_workflow(self):
        """E2Eãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ"""
        brain = SoulkunBrain(...)
        response = await brain.process_message(
            message="ã‚¿ã‚¹ã‚¯ã€Œå ±å‘Šæ›¸ä½œæˆã€ã‚’ä½œã£ã¦ã€ç”°ä¸­ã•ã‚“ã«å‰²ã‚Šå½“ã¦ã¦",
            room_id="123",
            account_id="456",
            sender_name="èŠåœ°",
        )
        assert response.success
        # ä¸¡æ–¹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
        ...
```

---

## 21.10 å®Ÿè£…é †åº

| é †åº | ã‚¿ã‚¹ã‚¯ | å„ªå…ˆåº¦ | æƒ³å®šå·¥æ•° |
|------|--------|--------|----------|
| 1 | ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾© | é«˜ | å° |
| 2 | DBãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | é«˜ | å° |
| 3 | TaskDecomposerå®Ÿè£… | é«˜ | ä¸­ |
| 4 | ExecutionPlannerå®Ÿè£… | é«˜ | ä¸­ |
| 5 | ProgressTrackerå®Ÿè£… | ä¸­ | å° |
| 6 | QualityCheckerå®Ÿè£… | ä¸­ | å° |
| 7 | ExceptionHandlerå®Ÿè£… | ä¸­ | ä¸­ |
| 8 | EscalationManagerå®Ÿè£… | ä¸­ | ä¸­ |
| 9 | WorkflowExecutorå®Ÿè£… | é«˜ | å¤§ |
| 10 | ExecutionExcellenceçµ±åˆ | é«˜ | ä¸­ |
| 11 | è„³ã¸ã®çµ±åˆ | é«˜ | ä¸­ |
| 12 | ãƒ†ã‚¹ãƒˆè¿½åŠ  | é«˜ | ä¸­ |
| 13 | æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ | é«˜ | å° |

---

## 21.11 ãƒªã‚¹ã‚¯ã¨å¯¾ç­–

| ãƒªã‚¹ã‚¯ | å½±éŸ¿ | å¯¾ç­– |
|--------|------|------|
| ç„¡é™ãƒ«ãƒ¼ãƒ— | ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢ | æœ€å¤§å®Ÿè¡Œå›æ•°åˆ¶é™ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š |
| ãƒªã‚½ãƒ¼ã‚¹æ¯æ¸‡ | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹ | ä¸¦åˆ—å®Ÿè¡Œæ•°åˆ¶é™ã€ã‚­ãƒ¥ãƒ¼ç®¡ç† |
| ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³éå¤š | ãƒ¦ãƒ¼ã‚¶ãƒ¼ç–²ã‚Œ | é–¾å€¤èª¿æ•´ã€è‡ªå‹•è§£æ±ºç‡å‘ä¸Š |
| å“è³ªãƒã‚§ãƒƒã‚¯èª¤æ¤œçŸ¥ | ç„¡é§„ãªä¸­æ–­ | é–¾å€¤ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã€å­¦ç¿’ã«ã‚ˆã‚‹æ”¹å–„ |
| è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆèª¤åˆ†è§£ | æ„å›³ã¨ç•°ãªã‚‹å®Ÿè¡Œ | ç¢ºèªãƒ•ãƒ­ãƒ¼è¿½åŠ ã€LLMç²¾åº¦å‘ä¸Š |

---

## 21.12 æˆåŠŸæŒ‡æ¨™

| æŒ‡æ¨™ | ç¾çŠ¶ | Phase 2Lå®Œäº†å¾Œç›®æ¨™ |
|------|------|-------------------|
| è¤‡é›‘ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Œé‚ç‡ | N/A | 80%ä»¥ä¸Š |
| ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¿œç­”æ™‚é–“ | N/A | å¹³å‡5åˆ†ä»¥å†… |
| è‡ªå‹•ãƒªã‚«ãƒãƒªãƒ¼æˆåŠŸç‡ | N/A | 70%ä»¥ä¸Š |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦ï¼ˆè¤‡é›‘ã‚¿ã‚¹ã‚¯ï¼‰ | N/A | 4.0/5.0ä»¥ä¸Š |

---

**[ğŸ“ ç›®æ¬¡ã«æˆ»ã‚‹](00_README.md)**
