"""
ç›®æ¨™è¨­å®šå¯¾è©±ãƒ•ãƒ­ãƒ¼ç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆPhase 2.5 v1.8 - ç¥çµŒæ¥ç¶šä¿®ç†ç‰ˆï¼‰

ã‚¢ãƒãƒ¼ãƒ–ãƒ¡ãƒ³ãƒˆç¤¾ãƒ»é¸æŠç†è«–ã«åŸºã¥ãç›®æ¨™è¨­å®šå¯¾è©±ã‚’ç®¡ç†ã€‚
WHY â†’ WHAT â†’ HOW ã®é †ã§ä¸€å•ä¸€ç­”å½¢å¼ã§ç›®æ¨™ã‚’è¨­å®šã™ã‚‹ã€‚

v1.8 å¤‰æ›´ç‚¹ï¼ˆç¥çµŒæ¥ç¶šä¿®ç†ï¼‰:
- çŠ¶æ…‹ç®¡ç†ã‚’ brain_conversation_states ã«ä¸€æœ¬åŒ–
- å¯¾è©±ãƒ­ã‚°ã‚’ brain_dialogue_logs ã«ä¸€æœ¬åŒ–
- goal_setting_sessions / goal_setting_logs ã¸ã®ä¾å­˜ã‚’å‰Šé™¤
- user_id ã¨ã—ã¦ ChatWork account_id ã‚’ä½¿ç”¨ï¼ˆè„³ã®è¨­è¨ˆã«æº–æ‹ ï¼‰

v1.7 å¤‰æ›´ç‚¹:
- è‡¨æ©Ÿå¿œå¤‰ãªå¯¾å¿œï¼ˆAdaptive Response Enhancementï¼‰
  - è³ªå•æ¤œå‡ºï¼ˆï¼Ÿã§çµ‚ã‚ã‚‹ã€ã€Œã©ã†ã—ãŸã‚‰ã„ã„ã€ç­‰ï¼‰
  - å›°æƒ‘æ¤œå‡ºï¼ˆå…¨ã‚¹ãƒ†ãƒƒãƒ—ã§ã€Œã‚ã‹ã‚‰ãªã„ã€ã€Œé›£ã—ã„ã€ç­‰ï¼‰
  - æ¥µç«¯ã«çŸ­ã„å›ç­”ã®æ¤œå‡ºï¼ˆ<5æ–‡å­—ã€5-10æ–‡å­—ï¼‰
  - å…·ä½“æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã®å¼·åŒ–
  - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆèªè­˜ï¼ˆå‰å›ç­”ã®å‚ç…§ã€ãƒªãƒˆãƒ©ã‚¤å›æ•°ã«å¿œã˜ãŸå¯¾å¿œï¼‰
  - æ–°è¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¿½åŠ 

ä½¿ç”¨ä¾‹:
    from lib.goal_setting import GoalSettingDialogue

    dialogue = GoalSettingDialogue(pool, room_id, account_id)
    response = dialogue.process_message(user_message)
"""

from datetime import datetime, timedelta, date
from decimal import Decimal
from typing import Optional, Dict, Any, Tuple
from uuid import uuid4
from sqlalchemy import text
import json
import re
import os
import httpx

# LLM APIè¨­å®š
OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY", "")
LLM_MODEL = "google/gemini-2.0-flash-001"
LLM_TIMEOUT = 30.0

# é•·æ–‡ã®é–¾å€¤ï¼ˆã“ã®æ–‡å­—æ•°ä»¥ä¸Šãªã‚‰LLMè§£æã‚’å®Ÿè¡Œï¼‰
LONG_RESPONSE_THRESHOLD = 100

# ä¸æº€æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
FRUSTRATION_PATTERNS = [
    "ç­”ãˆãŸã˜ã‚ƒã‚“", "ç­”ãˆãŸã‚ˆ", "è¨€ã£ãŸã˜ã‚ƒã‚“", "è¨€ã£ãŸã‚ˆ",
    "ã•ã£ãè¨€ã£ãŸ", "ã‚‚ã†è¨€ã£ãŸ", "æ—¢ã«ç­”ãˆãŸ", "åŒã˜ã“ã¨",
    "ä½•å›è¨€ãˆã°", "ç¹°ã‚Šè¿”ã—", "ã¡ã‚ƒã‚“ã¨èª­ã‚“ã§", "èã„ã¦ã‚‹ï¼Ÿ"
]

# ç¢ºèªOKãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆLLMæŠ½å‡ºå¾Œã®ç¢ºèªã«ä½¿ç”¨ï¼‰
CONFIRMATION_PATTERNS = [
    "ok", "OK", "ï½ï½‹", "ï¼¯ï¼«", "ãŠã£ã‘ãƒ¼", "ã‚ªãƒƒã‚±ãƒ¼",
    "åˆã£ã¦ã‚‹", "ã‚ã£ã¦ã‚‹", "ãã®é€šã‚Š", "ãã®ã¨ãŠã‚Š",
    "ã†ã‚“", "ã¯ã„", "ã„ã„ã‚ˆ", "å¤§ä¸ˆå¤«", "å•é¡Œãªã„",
    "ãã‚Œã§", "ãã‚Œã§ã„ã„", "ã„ã„ã§ã™", "ã‚ªãƒ¼ã‚±ãƒ¼"
]

# v10.40.1: å¦å®šæ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã€Œåˆã£ã¦ã‚‹ã‘ã©ã€ç­‰ã‚’æ¤œå‡ºï¼‰
# ã“ã‚Œã‚‰ãŒå«ã¾ã‚Œã‚‹å ´åˆã€è‚¯å®šèªãŒã‚ã£ã¦ã‚‚ confirmed=False ã«ã™ã‚‹
BUT_CONNECTOR_PATTERNS = [
    "ã‘ã©", "ã ã‘ã©", "ã‘ã‚Œã©", "ã ã‘ã‚Œã©",
    "ãŒã€", "ãŒï¼Œ", "ãŸã ã€", "ãŸã ï¼Œ",
    "ã§ã‚‚", "ã—ã‹ã—", "ä¸€æ–¹ã§", "ãŸã ã—",
    "ã‚“ã ã‘ã©", "ã‚“ã§ã™ã‘ã©", "ã®ã§ã™ãŒ", "ã‚“ã§ã™ãŒ",
]

# v10.40.1: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã€Œè©•ä¾¡ã—ã¦ã€ç­‰ã‚’æ¤œå‡ºï¼‰
# ã“ã‚Œã‚‰ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ç™»éŒ²ã›ãšã«å°ãã®å¯¾è©±ã«å…¥ã‚‹
FEEDBACK_REQUEST_PATTERNS = [
    # è©•ä¾¡ãƒ»ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚
    "ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯", "è©•ä¾¡", "è¦‹ã¦", "ã©ã†æ€ã†", "ã©ã†ã‹ãª",
    "æ­£ã—ã„", "åˆã£ã¦ã‚‹ã‹", "é–“é•ã£ã¦ãªã„", "ã“ã‚Œã§ã„ã„ï¼Ÿ",
    "ã“ã‚Œã§ã„ã„", "å¤§ä¸ˆå¤«ï¼Ÿ", "å¤§ä¸ˆå¤«ã‹ãª", "ã„ã„ã®ï¼Ÿ",
    # æ”¹å–„ãƒ»ã‚¢ãƒ‰ãƒã‚¤ã‚¹è¦æ±‚
    "æ”¹å–„", "ã‚¢ãƒ‰ãƒã‚¤ã‚¹", "æ•™ãˆã¦", "ã©ã†ã™ã‚Œã°", "ã©ã†ã—ãŸã‚‰",
    "è¶³ã‚Šãªã„", "ä¸è¶³", "æŠœã‘ã¦", "æ¼ã‚Œã¦",
    # åˆ†è§£ãƒ»å…·ä½“åŒ–è¦æ±‚
    "åˆ†è§£", "ç´°ã‹ã", "å…·ä½“çš„", "ãƒ–ãƒ¬ã‚¤ã‚¯ãƒ€ã‚¦ãƒ³",
    "ç›®å…ˆ", "çŸ­æœŸ", "ä»Šæœˆ", "ä»Šé€±", "ä»Šæ—¥",
    # ç¢ºèªãƒ»è³ªå•è¦æ±‚
    "ã‚ã‹ã‚‹ï¼Ÿ", "ã‚ã‹ã‚Šã¾ã™ï¼Ÿ", "ä¼ã‚ã£ã¦", "ç†è§£ã—ã¦",
    "èã„ã¦", "èããŸã„", "è³ªå•", "ç›¸è«‡",
]

# v10.40.2: è¿·ã„ãƒ»ä¸å®‰ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã€Œä¸å®‰ã€ã€Œè‡ªä¿¡ãªã„ã€ç­‰ã‚’æ¤œå‡ºï¼‰
# ã“ã‚Œã‚‰ãŒå«ã¾ã‚Œã‚‹å ´åˆã‚‚ã€ç™»éŒ²ã›ãšã«å°ãã®å¯¾è©±ã«å…¥ã‚‹
DOUBT_ANXIETY_PATTERNS = [
    # ä¸å®‰ãƒ»è‡ªä¿¡ã®ãªã•
    "ä¸å®‰", "è‡ªä¿¡ãªã„", "è‡ªä¿¡ãŒãªã„", "è‡ªä¿¡ãªã•ãã†",
    "é•ã†ã‹ã‚‚", "é–“é•ã£ã¦ã‚‹ã‹ã‚‚", "ã“ã‚Œã˜ã‚ƒãªã„",
    "ã‚ã‹ã‚‰ãªã„", "ã‚ã‹ã‚“ãªã„", "è¿·ã†", "è¿·ã£ã¦",
    # æ›–æ˜§ãƒ»ä¸ç¢ºå®Ÿ
    "æ›–æ˜§", "ã‚ã„ã¾ã„", "ã¼ã‚“ã‚„ã‚Š", "æ¼ ç„¶",
    "ãµã‚ã£ã¨", "ãªã‚“ã¨ãªã", "é©å½“",
    # v10.40.6: å¾®å¦™ãªåå¿œã‚‚è¿·ã„ã¨ã—ã¦æ¤œå‡º
    "å¾®å¦™", "ã†ãƒ¼ã‚“", "ã³ã¿ã‚‡ã†",
    # å¿ƒé…ãƒ»æ‡¸å¿µ
    "å¿ƒé…", "ä¸ååˆ†", "è¶³ã‚Šã¦ã‚‹ï¼Ÿ", "ã¡ã‚ƒã‚“ã¨ã—ã¦",
]

# v10.40.3: æ˜ç¤ºçš„ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³
# ã“ã‚Œã‚‰ãŒå«ã¾ã‚Œã‚‹å ´åˆã®ã¿ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦æœ€åˆã‹ã‚‰é–‹å§‹
RESTART_PATTERNS = [
    "ã‚‚ã†ä¸€åº¦", "æœ€åˆã‹ã‚‰", "ã‚„ã‚Šç›´", "ãƒªã‚»ãƒƒãƒˆ", "ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ",
    "åˆã‚ã‹ã‚‰", "ã¯ã˜ã‚ã‹ã‚‰", "ä»•åˆ‡ã‚Šç›´", "ã‚„ã‚ŠãªãŠã—",
    "æ–°ã—ãç›®æ¨™", "åˆ¥ã®ç›®æ¨™", "é•ã†ç›®æ¨™",
]


def _wants_restart(text: str) -> bool:
    """
    v10.40.3: æ˜ç¤ºçš„ãªãƒªã‚¹ã‚¿ãƒ¼ãƒˆè¦æ±‚ã‚’æ¤œå‡º

    ã€Œã‚‚ã†ä¸€åº¦ç›®æ¨™è¨­å®šã—ãŸã„ã€ã€Œã‚„ã‚Šç›´ã—ãŸã„ã€ç­‰ã®å ´åˆã®ã¿ã€
    ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦æœ€åˆã‹ã‚‰é–‹å§‹ã™ã‚‹ã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        True: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆè¦æ±‚ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆï¼‰
        False: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆè¦æ±‚ã§ã¯ãªã„ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶™ç¶šï¼‰
    """
    text_lower = text.lower()
    return any(pattern in text_lower for pattern in RESTART_PATTERNS)


def _has_but_connector(text: str) -> bool:
    """
    v10.40.1: å¦å®šæ¥ç¶šï¼ˆã€Œã‘ã©ã€ã€Œã ã‘ã©ã€ç­‰ï¼‰ã‚’æ¤œå‡º

    ã€Œåˆã£ã¦ã‚‹ã‘ã©ã€ã®ã‚ˆã†ãªå ´åˆã€confirmed=False ã«ã™ã‚‹ãŸã‚ã®ã‚¬ãƒ¼ãƒ‰ã€‚
    ã“ã‚Œã¯å¿œæ€¥å‡¦ç½®ã§ã‚ã‚Šã€å°†æ¥çš„ã«ã¯ brain/understanding.py ã«ç§»è¡Œäºˆå®šã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        True: å¦å®šæ¥ç¶šãŒå«ã¾ã‚Œã‚‹ï¼ˆç¢ºèªã¨ã—ã¦æ‰±ã‚ãªã„ï¼‰
        False: å¦å®šæ¥ç¶šãŒãªã„
    """
    text_lower = text.lower()
    return any(pattern in text_lower for pattern in BUT_CONNECTOR_PATTERNS)


def _has_feedback_request(text: str) -> bool:
    """
    v10.40.1: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ã‚’æ¤œå‡º

    ã€Œãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã—ã¦ã€ã€Œæ­£ã—ã„ï¼Ÿã€ç­‰ã®å ´åˆã€ç™»éŒ²ã›ãšã«å°ãã®å¯¾è©±ã«å…¥ã‚‹ã€‚
    ã“ã‚Œã¯å¿œæ€¥å‡¦ç½®ã§ã‚ã‚Šã€å°†æ¥çš„ã«ã¯ brain/understanding.py ã«ç§»è¡Œäºˆå®šã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        True: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ãŒå«ã¾ã‚Œã‚‹ï¼ˆç™»éŒ²ã—ãªã„ï¼‰
        False: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ãŒãªã„
    """
    text_lower = text.lower()
    return any(pattern in text_lower for pattern in FEEDBACK_REQUEST_PATTERNS)


def _has_doubt_or_anxiety(text: str) -> bool:
    """
    v10.40.2: è¿·ã„ãƒ»ä¸å®‰ã‚’æ¤œå‡º

    ã€Œä¸å®‰ã€ã€Œè‡ªä¿¡ãªã„ã€ã€Œé•ã†ã‹ã‚‚ã€ç­‰ã®å ´åˆã€å°ãã®å¯¾è©±ã«å…¥ã‚‹ã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        True: è¿·ã„ãƒ»ä¸å®‰ãŒå«ã¾ã‚Œã‚‹ï¼ˆå°ãã®å¯¾è©±ã¸ï¼‰
        False: è¿·ã„ãƒ»ä¸å®‰ãŒãªã„
    """
    text_lower = text.lower()
    return any(pattern in text_lower for pattern in DOUBT_ANXIETY_PATTERNS)


def _is_pure_confirmation(text: str) -> bool:
    """
    v10.40.1: ç´”ç²‹ãªç¢ºèªã‹ã©ã†ã‹ã‚’åˆ¤å®š

    confirmed = è‚¯å®šèªã‚ã‚Š AND å¦å®šæ¥ç¶šãªã— AND FBè¦æ±‚ãªã—

    ã“ã‚Œã«ã‚ˆã‚Šã€Œåˆã£ã¦ã‚‹ã‘ã©ã€œã€ã€ŒOKã ã‘ã©æ•™ãˆã¦ã€ç­‰ã§ã®èª¤ç™»éŒ²ã‚’é˜²æ­¢ã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        True: ç´”ç²‹ãªç¢ºèªï¼ˆç™»éŒ²OKï¼‰
        False: è¿½åŠ è¦æ±‚ã‚ã‚Šï¼ˆç™»éŒ²ã—ãªã„ï¼‰
    """
    text_lower = text.lower().strip()

    # 1. è‚¯å®šèªãƒã‚§ãƒƒã‚¯
    has_confirmation = any(
        pattern in text_lower for pattern in CONFIRMATION_PATTERNS
    )
    if not has_confirmation:
        return False

    # 2. å¦å®šæ¥ç¶šãƒã‚§ãƒƒã‚¯ï¼ˆã€Œã‘ã©ã€ç­‰ãŒã‚ã‚Œã°NGï¼‰
    if _has_but_connector(text):
        print(f"   âš ï¸ å¦å®šæ¥ç¶šæ¤œå‡º: ç¢ºèªã¨ã—ã¦æ‰±ã‚ãªã„")
        return False

    # 3. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ãƒã‚§ãƒƒã‚¯
    if _has_feedback_request(text):
        print(f"   âš ï¸ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚æ¤œå‡º: ç¢ºèªã¨ã—ã¦æ‰±ã‚ãªã„")
        return False

    return True


# =============================================================================
# v10.40.3: ãƒ•ã‚§ãƒ¼ã‚ºè‡ªå‹•åˆ¤å®šï¼ˆPhase Auto-Inferenceï¼‰
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè©±ã‹ã‚‰WHY/WHAT/HOWã®å……è¶³åº¦ã‚’æ¨å®šã—ã€æ—¢ã«å……è¶³ã—ãŸãƒ•ã‚§ãƒ¼ã‚ºã‚’ã‚¹ã‚­ãƒƒãƒ—
# =============================================================================

# WHYå……è¶³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå°†æ¥åƒãƒ»ã‚ã‚ŠãŸã„å§¿ãƒ»å‹•æ©Ÿï¼‰
WHY_FULFILLED_PATTERNS = [
    # ã‚ã‚ŠãŸã„å§¿
    "ãªã‚ŠãŸã„", "ç›®æŒ‡ã—ã¦", "ç›®æŒ‡ã™", "ç†æƒ³",
    # å‹•æ©Ÿãƒ»ç†ç”±
    "ãŸã‚ã«", "ã ã‹ã‚‰", "ã—ãŸãã¦", "ã—ãŸã„ã‹ã‚‰",
    # ãƒ“ã‚¸ãƒ§ãƒ³ãƒ»å°†æ¥
    "å°†æ¥", "ã„ã¤ã‹", "ã‚†ãã‚†ã", "æœ€çµ‚çš„ã«",
    # ä¾¡å€¤è¦³
    "å¤§äº‹", "å¤§åˆ‡", "é‡è¦", "æ„å‘³ãŒã‚ã‚‹",
    # é¡˜æœ›
    "ã€œã‚ˆã†ã«ãªã‚ŠãŸã„", "ã§ãã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„", "èªã‚ã‚‰ã‚ŒãŸã„",
]

# WHATå……è¶³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ†ãƒ¼ãƒãƒ»ç›®æ¨™ãƒ»æˆæœï¼‰
WHAT_FULFILLED_PATTERNS = [
    # ãƒ†ãƒ¼ãƒãƒ»é ˜åŸŸ
    "ãƒ†ãƒ¼ãƒ", "é ˜åŸŸ", "åˆ†é‡", "æ–¹å‘æ€§",
    # ç›®æ¨™ãƒ»ã‚´ãƒ¼ãƒ«
    "ç›®æ¨™", "ã‚´ãƒ¼ãƒ«", "é”æˆ", "æˆæœ",
    # æ•°å€¤ãƒ»KPI
    "ä»¶", "ä¸‡", "å††", "%", "äºº", "å›",
    # æœŸé™
    "ä»Šæœˆ", "ä»Šé€±", "æœˆæœ«", "é€±æœ«", "å¹´æœ«", "æœˆæ¬¡", "å¹´æ¬¡",
]

# HOWå……è¶³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆè¡Œå‹•ãƒ»ç¿’æ…£ãƒ»é »åº¦ï¼‰
HOW_FULFILLED_PATTERNS = [
    # é »åº¦
    "æ¯æ—¥", "æ¯é€±", "æ¯æœ", "æ¯æ™©", "é€±ã«", "æ—¥ã«",
    # è¡Œå‹•
    "ã‚„ã‚‹", "ã™ã‚‹", "è¡Œã†", "å®Ÿè·µ", "å®Ÿè¡Œ",
    # ç¿’æ…£
    "ç¿’æ…£", "ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³", "ç¶™ç¶š", "ç¶šã‘ã‚‹",
    # å…·ä½“çš„è¡Œå‹•
    "é›»è©±", "è¨ªå•", "ãƒ¡ãƒ¼ãƒ«", "å ±å‘Š", "ç¢ºèª",
]


def _infer_fulfilled_phases(text: str) -> Dict[str, bool]:
    """
    v10.40.3: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè©±ã‹ã‚‰ãƒ•ã‚§ãƒ¼ã‚ºã®å……è¶³åº¦ã‚’æ¨å®š

    WHY/WHAT/HOWãã‚Œãã‚Œã«ã¤ã„ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç™ºè©±ã«
    è©²å½“ã™ã‚‹æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã€‚

    Args:
        text: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

    Returns:
        {"why": True/False, "what": True/False, "how": True/False}
    """
    text_lower = text.lower()

    return {
        "why": any(p in text_lower for p in WHY_FULFILLED_PATTERNS),
        "what": any(p in text_lower for p in WHAT_FULFILLED_PATTERNS),
        "how": any(p in text_lower for p in HOW_FULFILLED_PATTERNS),
    }


def _get_next_unfulfilled_step(
    fulfilled: Dict[str, bool],
    current_step: str,
    session: Dict[str, Any]
) -> Optional[str]:
    """
    v10.40.3: æ¬¡ã«è³ªå•ã™ã¹ãã‚¹ãƒ†ãƒƒãƒ—ã‚’åˆ¤å®š

    æ—¢ã«å……è¶³ã—ã¦ã„ã‚‹ã‚¹ãƒ†ãƒƒãƒ—ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã€æœªå……è¶³ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿”ã™ã€‚
    ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«æ—¢ã«å›ç­”ãŒã‚ã‚‹å ´åˆã‚‚ã‚¹ã‚­ãƒƒãƒ—ã€‚

    Args:
        fulfilled: å„ãƒ•ã‚§ãƒ¼ã‚ºã®å……è¶³çŠ¶æ³
        current_step: ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—
        session: ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±

    Returns:
        æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—åï¼ˆ"why", "what", "how", "confirm"ï¼‰
        å…¨ã¦å……è¶³æ¸ˆã¿ãªã‚‰ "confirm"
    """
    steps = ["why", "what", "how"]

    for step in steps:
        # æ—¢ã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«å›ç­”ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        answer_key = f"{step}_answer"
        if session.get(answer_key):
            continue

        # ä»Šå›ã®ç™ºè©±ã§å……è¶³ã—ã¦ã„ãªã„å ´åˆã¯ã€ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’æ¬¡ã«
        if not fulfilled.get(step, False):
            return step

    # å…¨ã¦å……è¶³ â†’ confirm ã¸
    return "confirm"


# =====================================================
# å®šæ•°å®šç¾©
# =====================================================

# ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒ†ãƒƒãƒ—
STEPS = {
    "intro": "å°å…¥",
    "why": "WHYï¼ˆå†…ç™ºçš„å‹•æ©Ÿï¼‰",
    "what": "WHATï¼ˆçµæœç›®æ¨™ï¼‰",
    "how": "HOWï¼ˆè¡Œå‹•ç›®æ¨™ï¼‰",
    "confirm": "ç¢ºèª",  # v10.31.5: LLMæŠ½å‡ºå¾Œã®ç¢ºèªã‚¹ãƒ†ãƒƒãƒ—
    "complete": "å®Œäº†"
}

# ã‚¹ãƒ†ãƒƒãƒ—é·ç§»
STEP_ORDER = ["intro", "why", "what", "how", "complete"]

# æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°ï¼ˆåŒã˜ã‚¹ãƒ†ãƒƒãƒ—ã§ã®å†è³ªå•ä¸Šé™ï¼‰
MAX_RETRY_COUNT = 3


# =====================================================
# å¯¾è©±ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
# =====================================================

TEMPLATES = {
    # å°å…¥ï¼ˆã‚¢ã‚¸ã‚§ãƒ³ãƒ€æç¤º + WHYã¸ï¼‰
    "intro": """ğŸ¯ ç›®æ¨™è¨­å®šã‚’å§‹ã‚ã‚‹ã‚¦ãƒ«ï¼

ã‚½ã‚¦ãƒ«ãã‚“ã¨ä¸€ç·’ã«ã€{user_name}ã•ã‚“ã®ç›®æ¨™ã‚’æ•´ç†ã—ã¦ã„ã“ã†ã‚¦ãƒ«ğŸº

ğŸ“‹ ã“ã‚Œã‹ã‚‰3ã¤ã®è³ªå•ã‚’ã™ã‚‹ã‚¦ãƒ«ï¼š
1ï¸âƒ£ WHY - ãªãœãã®ç›®æ¨™ã‚’é”æˆã—ãŸã„ã®ã‹
2ï¸âƒ£ WHAT - å…·ä½“çš„ã«ä½•ã‚’é”æˆã—ãŸã„ã®ã‹
3ï¸âƒ£ HOW - ã©ã‚“ãªè¡Œå‹•ã§é”æˆã™ã‚‹ã®ã‹

ãã‚Œã§ã¯æœ€åˆã®è³ªå•ã‚¦ãƒ«ï¼

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â“ ã€WHYã€‘ã“ã®å…ˆã€ä»•äº‹ã‚’é€šã˜ã¦ã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ã§ã™ã‹ï¼Ÿ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€Œã€‡ã€‡ãªå­˜åœ¨ã«ãªã‚ŠãŸã„ã€ã€Œâ–³â–³ã‚’å®Ÿç¾ã—ãŸã„ã€ãªã©ã€
{user_name}ã•ã‚“ã®æƒ³ã„ã‚’è‡ªç”±ã«æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨""",

    # WHYå®Œäº† â†’ WHATè³ªå•
    "why_to_what": """ğŸ’¡ ãªã‚‹ã»ã©ã‚¦ãƒ«ï¼

{feedback}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â“ ã€WHATã€‘ãã®æƒ³ã„ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã€å…·ä½“çš„ã«ã©ã‚“ãªæˆæœã‚’å‡ºã—ãŸã„ã§ã™ã‹ï¼Ÿ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

æ•°å­—ã‚„æœŸé™ã‚’å…¥ã‚Œã¦ãã‚Œã‚‹ã¨ã€é€²æ—ãŒè¿½ã„ã‚„ã™ããªã‚‹ã‚¦ãƒ«ğŸº
ä¾‹ï¼šã€Œä»Šæœˆã®ç²—åˆ©300ä¸‡å††é”æˆã€ã€Œæœˆæœ«ã¾ã§ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå®Œäº†ã€""",

    # WHATå®Œäº† â†’ HOWè³ªå•
    "what_to_how": """ğŸ‘ ç´ æ™´ã‚‰ã—ã„ç›®æ¨™ã‚¦ãƒ«ï¼

{feedback}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â“ ã€HOWã€‘ãã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€æ¯æ—¥ãƒ»æ¯é€±ã©ã‚“ãªè¡Œå‹•ã‚’ã—ã¾ã™ã‹ï¼Ÿ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€Œæ¯æ—¥ã€‡ã€‡ã‚’ã™ã‚‹ã€ã€Œé€±ã«â–³å›â–¡â–¡ã‚’ã™ã‚‹ã€ãªã©ã€
å…·ä½“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ•™ãˆã¦ã‚¦ãƒ«ğŸº""",

    # HOWå®Œäº† â†’ ç›®æ¨™ç™»éŒ²
    "complete": """ğŸ‰ ç›®æ¨™è¨­å®šå®Œäº†ã‚¦ãƒ«ï¼

{user_name}ã•ã‚“ã®ç›®æ¨™ã‚’ã¾ã¨ã‚ãŸã‚¦ãƒ«ğŸº

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Œ WHYï¼ˆãªã‚ŠãŸã„å§¿ï¼‰
{why_answer}

ğŸ¯ WHATï¼ˆçµæœç›®æ¨™ï¼‰
{what_answer}

ğŸ’ª HOWï¼ˆè¡Œå‹•ç›®æ¨™ï¼‰
{how_answer}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… ç›®æ¨™ã‚’ç™»éŒ²ã—ãŸã‚¦ãƒ«ï¼

{user_name}ã•ã‚“ãªã‚‰çµ¶å¯¾é”æˆã§ãã‚‹ã£ã¦ã€ã‚½ã‚¦ãƒ«ãã‚“ã¯ä¿¡ã˜ã¦ã‚‹ã‚¦ãƒ«ğŸ’ªğŸº
æ¯æ—¥17æ™‚ã«é€²æ—ã‚’èãã‹ã‚‰ã€ä¸€ç·’ã«é ‘å¼µã£ã¦ã„ã“ã†ã‚¦ãƒ«âœ¨""",

    # v10.40.2: å°ãã®å¯¾è©±ï¼ˆç›®æ¨™ã®è³ªãƒã‚§ãƒƒã‚¯ï¼‰
    # ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚ã‚„è¿·ã„ãƒ»ä¸å®‰ã‚’æ¤œå‡ºã—ãŸå ´åˆã«ä½¿ç”¨
    "quality_check": """ğŸº {user_name}ã•ã‚“ã€ç¢ºèªã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ï¼

ã‚½ã‚¦ãƒ«ãã‚“ã‚‚ä¸€ç·’ã«è€ƒãˆã•ã›ã¦ã‚¦ãƒ«ã€‚

{quality_feedback}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{quality_questions}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ ã“ã®æ–¹å‘ã§ç™»éŒ²ã™ã‚‹ï¼Ÿãã‚Œã¨ã‚‚èª¿æ•´ã™ã‚‹ï¼Ÿ
ã€ŒOKã€ã§ç™»éŒ²ã€ã‚‚ã—ãã¯ä¿®æ­£ã—ãŸã„éƒ¨åˆ†ã‚’æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: æŠ½è±¡çš„ã™ãã‚‹
    "ng_abstract": """ğŸ¤” ã‚‚ã†å°‘ã—å…·ä½“çš„ã«æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ï¼

ã€Œ{user_answer}ã€ã¨ã„ã†æ°—æŒã¡ã¯ã¨ã¦ã‚‚ã‚ã‹ã‚‹ã‚¦ãƒ«ğŸº

ã§ã‚‚ã€ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ãã‚Œã‚‹ã¨å¬‰ã—ã„ã‚¦ãƒ«ï¼

ä¾‹ãˆã°...
- ã„ã¤ã¾ã§ã«ï¼Ÿ
- ã©ã®ãã‚‰ã„ï¼Ÿ
- ä½•ã‚’ï¼Ÿ

ã‚‚ã†ä¸€åº¦ã€å…·ä½“çš„ã«æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: è»¢è·ãƒ»å‰¯æ¥­å¿—å‘
    "ng_career": """ğŸ’­ ã„ã‚ã‚“ãªå¯èƒ½æ€§ã‚’è€ƒãˆã¦ã„ã‚‹ã‚“ã ã­ï¼

{user_name}ã•ã‚“ãŒã‚­ãƒ£ãƒªã‚¢ã«ã¤ã„ã¦çœŸå‰£ã«è€ƒãˆã¦ã„ã‚‹ã®ã¯ç´ æ™´ã‚‰ã—ã„ã‚¦ãƒ«ğŸº

ã¨ã“ã‚ã§ã€ã‚‚ã—ä»Šã®ä¼šç¤¾ã§ã€Œã“ã‚ŒãŒå®Ÿç¾ã§ããŸã‚‰æœ€é«˜ã ãªã€ã£ã¦æ€ã†ã“ã¨ã¯ã‚ã‚‹ã‹ãªï¼Ÿ

ä¼šç¤¾ã®ä¸­ã§é”æˆã—ãŸã„ã“ã¨ã€æˆã—é‚ã’ãŸã„ã“ã¨ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: ä»–è²¬æ€è€ƒ
    "ng_other_blame": """ğŸ˜Š å¤§å¤‰ãªçŠ¶æ³ãªã‚“ã ã­...

{user_name}ã•ã‚“ã®æ°—æŒã¡ã€ã‚ˆãã‚ã‹ã‚‹ã‚¦ãƒ«ğŸº
ç’°å¢ƒã‚„å‘¨ã‚Šã®äººã«å½±éŸ¿ã‚’å—ã‘ã‚‹ã“ã¨ã£ã¦ã‚ã‚‹ã‚ˆã­ã€‚

ã§ã‚‚ã­ã€ã‚½ã‚¦ãƒ«ãã‚“ã¯{user_name}ã•ã‚“ã®å¯èƒ½æ€§ã‚’ä¿¡ã˜ã¦ã‚‹ã‚¦ãƒ«ï¼

ã€Œè‡ªåˆ†ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã‚‹ã“ã¨ã€ã§ã€å¤‰ãˆã¦ã„ããŸã„ã“ã¨ã¯ã‚ã‚‹ã‹ãªï¼Ÿ
{user_name}ã•ã‚“è‡ªèº«ãŒè¡Œå‹•ã§ãã‚‹ã“ã¨ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: ç›®æ¨™ãŒãªã„
    "ng_no_goal": """ğŸŒŸ ç›®æ¨™ãŒãªã„ã£ã¦æ„Ÿã˜ã‚‹ã“ã¨ã€ã‚ã‚‹ã‚ˆã­ï¼

ã§ã‚‚ã­ã€{user_name}ã•ã‚“ã«ã‚‚å¿…ãšã€Œã“ã†ãªã£ãŸã‚‰ã„ã„ãªã€ã£ã¦æ€ã†ã“ã¨ãŒã‚ã‚‹ã¯ãšã‚¦ãƒ«ğŸº

å°ã•ãªã“ã¨ã§ã‚‚å¤§ä¸ˆå¤«ã‚¦ãƒ«ï¼
- ã€Œã‚‚ã†å°‘ã—ã€‡ã€‡ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚ŠãŸã„ã€
- ã€Œâ–³â–³ãªä»•äº‹ãŒã—ã¦ã¿ãŸã„ã€
- ã€Œâ–¡â–¡ã‚’é”æˆã—ã¦ã¿ãŸã„ã€

ã©ã‚“ãªå°ã•ãªã“ã¨ã§ã‚‚ã„ã„ã‹ã‚‰ã€æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: ç›®æ¨™ãŒé«˜ã™ãã‚‹
    "ng_too_high": """ğŸš€ å¤§ããªç›®æ¨™ã‚’æŒã£ã¦ã‚‹ã‚“ã ã­ï¼

{user_name}ã•ã‚“ã®å¿—ã®é«˜ã•ã€ç´ æ™´ã‚‰ã—ã„ã‚¦ãƒ«ğŸº

ãŸã ã€ã¾ãšã¯ã€Œæœ€åˆã®ä¸€æ­©ã€ã‚’è€ƒãˆã¦ã¿ãªã„ï¼Ÿ

ãã®å¤§ããªç›®æ¨™ã«å‘ã‹ã£ã¦ã€ä»Šæœˆé”æˆã§ããã†ãªãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ã¯ä½•ã‹ãªï¼Ÿ
å°ã•ãªæˆåŠŸã‚’ç©ã¿é‡ã­ã¦ã„ã“ã†ã‚¦ãƒ«ğŸºâœ¨""",

    # NGå¿œç­”: çµæœç›®æ¨™ã¨ç¹‹ãŒã‚‰ãªã„
    "ng_not_connected": """ğŸ”— ã¡ã‚‡ã£ã¨ç¢ºèªã•ã›ã¦ã‚¦ãƒ«ï¼

ã•ã£ãæ•™ãˆã¦ãã‚ŒãŸçµæœç›®æ¨™ã¯ã€Œ{what_answer}ã€ã ã£ãŸã‚ˆã­ï¼Ÿ

ä»Šã®è¡Œå‹•ç›®æ¨™ã€Œ{user_answer}ã€ãŒã€ã©ã†çµæœã«ã¤ãªãŒã‚‹ã‹æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº

ã‚‚ã—åˆ¥ã®è¡Œå‹•ã®ã»ã†ãŒçµæœã«ç›´çµã—ãã†ãªã‚‰ã€ãã‚Œã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«âœ¨""",

    # NGå¿œç­”: ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ˜ãƒ«ã‚¹æ‡¸å¿µ
    "ng_mental_health": """ğŸ’™ {user_name}ã•ã‚“ã€å¤§ä¸ˆå¤«...ï¼Ÿ

ã¡ã‚‡ã£ã¨è¾›ãã†ã«è¦‹ãˆã‚‹ã‚¦ãƒ«ğŸº

ã‚‚ã—ä»Šã—ã‚“ã©ã„çŠ¶æ…‹ãªã‚‰ã€ç„¡ç†ã«ç›®æ¨™ã‚’ç«‹ã¦ãªãã¦ã‚‚ã„ã„ã‚¦ãƒ«ã€‚
ã¾ãšã¯è‡ªåˆ†ã®å¿ƒã¨ä½“ã‚’å¤§äº‹ã«ã—ã¦ã»ã—ã„ã‚¦ãƒ«ã€‚

ã‚‚ã—ã‚ˆã‹ã£ãŸã‚‰ã€ä¸Šå¸ã‚„äººäº‹ã®äººã«ç›¸è«‡ã—ã¦ã¿ã¦ã‚‚ã„ã„ã‹ã‚‚ã‚¦ãƒ«ã€‚
ã‚½ã‚¦ãƒ«ãã‚“ã¯ã„ã¤ã§ã‚‚{user_name}ã•ã‚“ã®å‘³æ–¹ã‚¦ãƒ«ğŸºğŸ’™

ç›®æ¨™è¨­å®šã¯ã€å…ƒæ°—ãªæ™‚ã«ã¾ãŸã‚„ã‚ã†ã‚¦ãƒ«âœ¨""",

    # NGå¿œç­”: ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆç›®æ¨™ã®ã¿
    "ng_private_only": """ğŸƒ ç´ æ•µãªç›®æ¨™ã‚¦ãƒ«ï¼

ã€Œ{user_answer}ã€ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚’å……å®Ÿã•ã›ã‚‹ã®ã¯å¤§äº‹ã‚¦ãƒ«ğŸº

ã¨ã“ã‚ã§ã€ãŠä»•äº‹ã®æ–¹ã§ã‚‚ä½•ã‹é”æˆã—ãŸã„ã“ã¨ã¯ã‚ã‚‹ã‹ãªï¼Ÿ

ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã¨ä»•äº‹ã€ä¸¡æ–¹å……å®Ÿã•ã›ã¦ã„ã‘ãŸã‚‰æœ€é«˜ã‚¦ãƒ«ï¼
ä»•äº‹ã§ã®ç›®æ¨™ã‚‚æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # =====================================================
    # v1.7 æ–°è¦: ãƒ˜ãƒ«ãƒ—ãƒ»è³ªå•å¯¾å¿œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    # =====================================================

    # è³ªå•ã¸ã®å›ç­”: WHYã‚¹ãƒ†ãƒƒãƒ—
    "help_question_why": """ğŸ“ è‰¯ã„è³ªå•ã‚¦ãƒ«ï¼èª¬æ˜ã™ã‚‹ã­ï¼

ã€WHYã€‘ã¯ã€Œã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ã‹ã€ã‚’èã„ã¦ã„ã‚‹ã‚¦ãƒ«ğŸº

ä¾‹ãˆã°ã“ã‚“ãªæ„Ÿã˜ï¼š
â€¢ ã€Œãƒãƒ¼ãƒ ã‚’å¼•ã£å¼µã‚Œã‚‹ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„ã€
â€¢ ã€ŒãŠå®¢æ§˜ã‹ã‚‰æŒ‡åã•ã‚Œã‚‹å–¶æ¥­ã«ãªã‚ŠãŸã„ã€
â€¢ ã€Œå¾Œè¼©ã«é ¼ã‚‰ã‚Œã‚‹å…ˆè¼©ã«ãªã‚ŠãŸã„ã€
â€¢ ã€Œã“ã®åˆ†é‡ã®ç¬¬ä¸€äººè€…ã¨ã—ã¦èªã‚ã‚‰ã‚ŒãŸã„ã€

ä»•äº‹ã‚’é€šã˜ã¦ã€{user_name}ã•ã‚“ãŒã©ã‚“ãªå§¿ã‚’ç›®æŒ‡ã—ã¦ã„ã‚‹ã‹ã€
è‡ªç”±ã«æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # è³ªå•ã¸ã®å›ç­”: WHATã‚¹ãƒ†ãƒƒãƒ—
    "help_question_what": """ğŸ“ è‰¯ã„è³ªå•ã‚¦ãƒ«ï¼èª¬æ˜ã™ã‚‹ã­ï¼

ã€WHATã€‘ã¯ã€Œå…·ä½“çš„ã«ä½•ã‚’é”æˆã—ãŸã„ã‹ã€ã‚’èã„ã¦ã„ã‚‹ã‚¦ãƒ«ğŸº

ä¾‹ãˆã°ã“ã‚“ãªæ„Ÿã˜ï¼š
â€¢ ã€Œä»Šæœˆã®å£²ä¸Šã‚’300ä¸‡å††é”æˆã™ã‚‹ã€
â€¢ ã€Œä»Šæœˆä¸­ã«æ–°è¦é¡§å®¢ã‚’5ä»¶ç²å¾—ã™ã‚‹ã€
â€¢ ã€Œæœˆæœ«ã¾ã§ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Œäº†ã•ã›ã‚‹ã€
â€¢ ã€Œä»Šé€±ä¸­ã«ææ¡ˆæ›¸ã‚’3æœ¬ä½œæˆã™ã‚‹ã€

**æ•°å­—ã‚„æœŸé™**ã‚’å…¥ã‚Œã¦ãã‚Œã‚‹ã¨ã€é€²æ—ãŒè¿½ã„ã‚„ã™ããªã‚‹ã‚¦ãƒ«ï¼
{user_name}ã•ã‚“ãŒé”æˆã—ãŸã„æˆæœã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # è³ªå•ã¸ã®å›ç­”: HOWã‚¹ãƒ†ãƒƒãƒ—
    "help_question_how": """ğŸ“ è‰¯ã„è³ªå•ã‚¦ãƒ«ï¼èª¬æ˜ã™ã‚‹ã­ï¼

ã€HOWã€‘ã¯ã€Œæ¯æ—¥ãƒ»æ¯é€±ã©ã‚“ãªè¡Œå‹•ã‚’ã™ã‚‹ã‹ã€ã‚’èã„ã¦ã„ã‚‹ã‚¦ãƒ«ğŸº

ä¾‹ãˆã°ã“ã‚“ãªæ„Ÿã˜ï¼š
â€¢ ã€Œæ¯æ—¥30åˆ†ã€è¦‹è¾¼ã¿å®¢ã«ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®é›»è©±ã‚’ã™ã‚‹ã€
â€¢ ã€Œé€±ã«3å›ã€ãŠå®¢æ§˜è¨ªå•ã‚’ã™ã‚‹ã€
â€¢ ã€Œæ¯æœ10åˆ†ã€æ¥­ç•Œãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€
â€¢ ã€Œæ¯æ—¥é€€å‹¤å‰ã«ç¿Œæ—¥ã®ã‚¿ã‚¹ã‚¯ã‚’æ•´ç†ã™ã‚‹ã€

ç›®æ¨™é”æˆã®ãŸã‚ã«ã€{user_name}ã•ã‚“ãŒ**ç¿’æ…£ã«ã—ãŸã„è¡Œå‹•**ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # å›°æƒ‘ãƒ»è¿·ã„: WHYã‚¹ãƒ†ãƒƒãƒ—
    "help_confused_why": """ğŸ¤” è¿·ã£ã¡ã‚ƒã†ã‚ˆã­ã€ã‚ã‹ã‚‹ã‚¦ãƒ«ï¼

{user_name}ã•ã‚“ã€æ€¥ã«ã€Œã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ï¼Ÿã€ã£ã¦èã‹ã‚Œã¦ã‚‚ã€
ã™ãã«ç­”ãˆãŒå‡ºãªã„ã“ã¨ã‚‚ã‚ã‚‹ã‚¦ãƒ«ğŸº

ã“ã‚“ãªé¢¨ã«è€ƒãˆã¦ã¿ã¦ã»ã—ã„ã‚¦ãƒ«ï¼š

1. **æœ€è¿‘ã€Œã‚„ã£ãŸï¼ã€ã¨æ€ãˆãŸç¬é–“**ã¯ä½•ã‹ãªï¼Ÿ
2. **ã€Œã“ã†ãªã‚ŒãŸã‚‰ã„ã„ãªã€**ã¨æ†§ã‚Œã‚‹å…ˆè¼©ã‚„åŒåƒšã¯ã„ã‚‹ã‹ãªï¼Ÿ
3. **1å¹´å¾Œã®è‡ªåˆ†**ãŒã©ã†ãªã£ã¦ã„ãŸã‚‰å¬‰ã—ã„ã‹ãªï¼Ÿ

å°ã•ãªã“ã¨ã§ã‚‚å¤§ä¸ˆå¤«ã‚¦ãƒ«ï¼
{user_name}ã•ã‚“ã®æ°—æŒã¡ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # å›°æƒ‘ãƒ»è¿·ã„: WHATã‚¹ãƒ†ãƒƒãƒ—
    "help_confused_what": """ğŸ¤” å…·ä½“çš„ãªæ•°å­—ã£ã¦ã€é›£ã—ã„ã‚ˆã­ï¼

{user_name}ã•ã‚“ã€å¤§ä¸ˆå¤«ã‚¦ãƒ«ï¼ä¸€ç·’ã«è€ƒãˆã‚ˆã†ã‚¦ãƒ«ğŸº

ã•ã£ãã€Œ{why_summary}ã€ã£ã¦æ•™ãˆã¦ãã‚ŒãŸã‚ˆã­ã€‚

ãã®æƒ³ã„ã‚’å¶ãˆã‚‹ãŸã‚ã«ã€ä»Šæœˆã‚„ã‚Œãã†ãªã“ã¨ã‚’è€ƒãˆã¦ã¿ã‚ˆã†ã‚¦ãƒ«ï¼š

â€¢ **æ•°ã§æ¸¬ã‚Œã‚‹ã“ã¨**: ã€‡ä»¶ã€ã€‡äººã€ã€‡å›ãªã©
â€¢ **æœŸé™ã§æ¸¬ã‚Œã‚‹ã“ã¨**: ã€‡æ—¥ã¾ã§ã«å®Œäº†ã€ã€‡æœˆæœ«ã¾ã§ã«æå‡ºãªã©
â€¢ **é”æˆåº¦ã§æ¸¬ã‚Œã‚‹ã“ã¨**: ã€‡%é”æˆã€ã€‡ç‚¹ä»¥ä¸Šãªã©

ã©ã‚Œã‹ãƒ”ãƒ³ã¨ãã‚‹ã‚‚ã®ã¯ã‚ã‚‹ã‹ãªï¼ŸğŸºâœ¨""",

    # å›°æƒ‘ãƒ»è¿·ã„: HOWã‚¹ãƒ†ãƒƒãƒ—
    "help_confused_how": """ğŸ¤” è¡Œå‹•ç›®æ¨™ã€è¿·ã†ã‚ˆã­ï¼

{user_name}ã•ã‚“ã€ä¸€ç·’ã«è€ƒãˆã‚ˆã†ã‚¦ãƒ«ğŸº

ç›®æ¨™ã¯ã€Œ{what_summary}ã€ã ã£ãŸã‚ˆã­ã€‚

ã“ã‚Œã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€**æ¯æ—¥ã¾ãŸã¯æ¯é€±ã§ãã‚‹å°ã•ãªè¡Œå‹•**ã‚’è€ƒãˆã¦ã¿ã‚ˆã†ã‚¦ãƒ«ï¼š

â€¢ **æ¯æ—¥5åˆ†ã§ã‚‚ã§ãã‚‹ã“ã¨**ã¯ä½•ã‹ãªï¼Ÿ
â€¢ **é€±ã«1å›ã¯å¿…ãšã‚„ã‚‹ã“ã¨**ã¯ä½•ã‹ãªï¼Ÿ
â€¢ **ç¿’æ…£ã«ã—ãŸã„ã“ã¨**ã¯ä½•ã‹ãªï¼Ÿ

å¤§ããªè¡Œå‹•ã˜ã‚ƒãªãã¦ã€**ç¶šã‘ã‚‰ã‚Œã‚‹å°ã•ãªè¡Œå‹•**ã§OKã‚¦ãƒ«ğŸºâœ¨""",

    # æ¥µç«¯ã«çŸ­ã„å›ç­”
    "too_short": """ğŸ¤” ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ï¼

ã€Œ{user_answer}ã€ã ã‘ã ã¨ã€ã‚½ã‚¦ãƒ«ãã‚“ã«ã¯{user_name}ã•ã‚“ã®æ°—æŒã¡ãŒ
ã‚ˆãã‚ã‹ã‚‰ãªã„ã‚¦ãƒ«ğŸº

{step_guidance}

{user_name}ã•ã‚“ã®è€ƒãˆã‚’ã€ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # ãƒªãƒˆãƒ©ã‚¤2å›ç›®ç”¨ï¼ˆå°‘ã—å„ªã—ã„ãƒˆãƒ¼ãƒ³ï¼‰
    "retry_gentle": """ğŸ˜Š å¤§ä¸ˆå¤«ã€ã‚†ã£ãã‚Šè€ƒãˆã‚ˆã†ã‚¦ãƒ«ï¼

{user_name}ã•ã‚“ã€ç„¦ã‚‰ãªãã¦ã„ã„ã‚¦ãƒ«ğŸº

{step_hint}

ã©ã‚“ãªå°ã•ãªã“ã¨ã§ã‚‚ã„ã„ã‹ã‚‰ã€{user_name}ã•ã‚“ã®è¨€è‘‰ã§æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # ãƒªãƒˆãƒ©ã‚¤3å›ç›®ç”¨ï¼ˆå—ã‘å…¥ã‚Œæº–å‚™ï¼‰
    "retry_accepting": """ğŸ‘ {user_name}ã•ã‚“ã®æ°—æŒã¡ã€å—ã‘å–ã£ãŸã‚¦ãƒ«ï¼

ã€Œ{user_answer}ã€ã¨ã„ã†æƒ³ã„ã€å¤§äº‹ã«ã—ã‚ˆã†ã‚¦ãƒ«ğŸº

ã“ã‚Œã§ã„ã„ãªã‚‰ã€ã“ã®ã¾ã¾æ¬¡ã«é€²ã‚‚ã†ã‚¦ãƒ«ï¼
ã‚‚ã—å¤‰ãˆãŸã„å ´åˆã¯ã€ã‚‚ã†ä¸€åº¦æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸºâœ¨""",

    # v10.22.1 æ–°è¦: ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†
    "exit": """ğŸ‘‹ ç›®æ¨™è¨­å®šã‚’çµ‚äº†ã™ã‚‹ã‚¦ãƒ«ï¼

{user_name}ã•ã‚“ã€ã¾ãŸç›®æ¨™ã‚’è¨­å®šã—ãŸããªã£ãŸã‚‰ã„ã¤ã§ã‚‚å£°ã‚’ã‹ã‘ã¦ã‚¦ãƒ«ğŸºâœ¨

ã€Œç›®æ¨™ã‚’è¨­å®šã—ãŸã„ã€ã¨è¨€ã£ã¦ãã‚ŒãŸã‚‰ã€ã„ã¤ã§ã‚‚å§‹ã‚ã‚‰ã‚Œã‚‹ã‚¦ãƒ«ï¼""",

    # =====================================================
    # v10.40.3: ã‚¹ãƒãƒ¼ãƒˆè³ªå•ï¼ˆãƒ•ã‚§ãƒ¼ã‚ºè‡ªå‹•åˆ¤å®šç”¨ï¼‰
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã‹ã‚‰æ—¢ã«åˆ†ã‹ã£ã¦ã„ã‚‹æƒ…å ±ã‚’æ´»ã‹ã—ãŸè³ªå•
    # =====================================================

    # ãƒ†ãƒ¼ãƒãŒåˆ†ã‹ã£ã¦ã„ã‚‹å ´åˆã®WHATè³ªå•ï¼ˆå…·ä½“åŒ–ã«çµã‚‹ï¼‰
    "smart_what_with_themes": """ğŸ¯ ãªã‚‹ã»ã©ï¼{themes}ã«åŠ›ã‚’å…¥ã‚Œã¦ã„ãã‚“ã ã­ï¼

ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ğŸº

ã§ã¯ã€ã“ã®ä¸­ã§ã¾ãš**ä»Šæœˆå…·ä½“çš„ã«é”æˆã—ãŸã„æˆæœ**ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ï¼

ä¾‹ãˆã°ï¼š
â€¢ ã€Œ{theme_example}ã§ã€‡ã€‡ã‚’é”æˆã€
â€¢ ã€Œã€‡ä»¶ã€ã€Œã€‡%ã€ã€Œã€‡æ—¥ã¾ã§ã«ã€ãªã©æ•°å­—ã§

ã©ã‚Œã‹1ã¤ã§ã„ã„ã‹ã‚‰ã€å…·ä½“çš„ã«æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨""",

    # æ–¹å‘æ€§ãŒåˆ†ã‹ã£ã¦ã„ã‚‹å ´åˆã®HOWè³ªå•
    "smart_how_with_goal": """ğŸ’ª ã€Œ{goal}ã€ã‚’ç›®æŒ‡ã™ã‚“ã ã­ï¼ç´ æ•µã‚¦ãƒ«ğŸº

ã‚ã¨å°‘ã—ï¼**æ¯æ—¥ãƒ»æ¯é€±ã®å…·ä½“çš„ãªè¡Œå‹•**ã‚’æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ï¼

ä¾‹ãˆã°ï¼š
â€¢ ã€Œæ¯æ—¥ã€‡ã€‡åˆ†ã€ã€Œé€±ã«ã€‡å›ã€
â€¢ ã€Œæ¯æœã€‡ã€‡ã‚’ã™ã‚‹ã€ã€Œå¸°å®…å‰ã«ã€‡ã€‡ã€

ã©ã‚“ãªè¡Œå‹•ã‚’ç¿’æ…£ã«ã™ã‚‹ã‹ã€æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨""",

    # è¤‡æ•°æƒ…å ±ãŒä¸€åº¦ã«æ¥ãŸæ™‚ã®ç¢ºèª
    "smart_confirm_extracted": """ğŸº {user_name}ã•ã‚“ã€ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ï¼

ã‚½ã‚¦ãƒ«ãã‚“ãªã‚Šã«æ•´ç†ã—ã¦ã¿ãŸã‚¦ãƒ«ï¼š

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ ã€WHY - æƒ³ã„ã€‘
{why_summary}

ğŸ¯ ã€WHAT - ç›®æŒ‡ã™ã‚´ãƒ¼ãƒ«ã€‘
{what_summary}

ğŸ’ª ã€HOW - å…·ä½“çš„ãªè¡Œå‹•ã€‘
{how_summary}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{missing_message}""",
}


# =====================================================
# ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
# =====================================================

PATTERN_KEYWORDS = {
    "ng_abstract": [
        "æˆé•·", "é ‘å¼µã‚‹", "è‰¯ããªã‚ŠãŸã„", "å‘ä¸Š", "ã‚¹ã‚­ãƒ«ã‚¢ãƒƒãƒ—",
        "ã‚‚ã£ã¨", "ã„ã„æ„Ÿã˜", "ã„ã‚ã„ã‚", "ãªã‚“ã¨ãªã", "ã¨ã‚Šã‚ãˆãš"
    ],
    "ng_career": [
        "è»¢è·", "å‰¯æ¥­", "å¸‚å ´ä¾¡å€¤", "ã©ã“ã§ã‚‚é€šç”¨", "ç‹¬ç«‹",
        "ãƒ•ãƒªãƒ¼ãƒ©ãƒ³ã‚¹", "èµ·æ¥­", "ä»–ç¤¾", "è¾ã‚", "é€€è·"
    ],
    "ng_other_blame": [
        "ä¸Šå¸ãŒ", "ä¼šç¤¾ãŒ", "ç’°å¢ƒãŒ", "ã›ã„ã§", "ã®ã›ã„",
        "è©•ä¾¡ã—ã¦ãã‚Œãªã„", "ã‚ã‹ã£ã¦ãã‚Œãªã„", "èªã‚ã¦ãã‚Œãªã„",
        "æ•™ãˆã¦ãã‚Œãªã„", "ã‚„ã‚‰ã›ã¦ãã‚Œãªã„"
    ],
    "ng_no_goal": [
        "ç‰¹ã«ãªã„", "ä»Šã®ã¾ã¾", "è€ƒãˆã¦ãªã„",
        "ãªã„ã§ã™", "ã‚ã‚Šã¾ã›ã‚“", "æ€ã„ã¤ã‹ãªã„"
    ],
    "ng_mental_health": [
        "ç–²ã‚ŒãŸ", "ã—ã‚“ã©ã„", "è¾›ã„", "ã‚„ã‚‹æ°—ãŒå‡ºãªã„", "é™ç•Œ",
        "ç„¡ç†", "æ­»ã«ãŸã„", "è¾ã‚ãŸã„", "æ¶ˆãˆãŸã„", "ã‚‚ã†å«Œ",
        "ã¤ã‚‰ã„", "ãã¤ã„", "ç—…ã‚“ã§", "é¬±", "ã†ã¤"
    ],
    "ng_private_only": [
        "ãƒ€ã‚¤ã‚¨ãƒƒãƒˆ", "è¶£å‘³", "æ—…è¡Œ", "ç—©ã›ãŸã„", "ç­‹ãƒˆãƒ¬",
        "è³‡æ ¼", "ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ", "ä¼‘ã¿", "ä¼‘æš‡"
    ],
    # v1.7 æ–°è¦: è³ªå•ãƒ»ãƒ˜ãƒ«ãƒ—è¦æ±‚ãƒ‘ã‚¿ãƒ¼ãƒ³
    "help_question": [
        "ã©ã†ã—ãŸã‚‰ã„ã„", "ã©ã†ã™ã‚Œã°", "ä½•ã‚’æ›¸ã‘ã°", "ã©ã‚“ãªã“ã¨",
        "ã©ã†ã„ã†", "ã©ã®ã‚ˆã†ãª", "ä½•ã‚’è¨€ãˆã°", "ä½•ã‚’ç­”ãˆã‚Œã°",
        "ä¾‹ãˆã°", "å…·ä½“çš„ã«ã¯", "æ•™ãˆã¦"
    ],
    # v1.7 æ–°è¦: å›°æƒ‘ãƒ»è¿·ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå…¨ã‚¹ãƒ†ãƒƒãƒ—å…±é€šï¼‰
    "help_confused": [
        "ã‚ã‹ã‚‰ãªã„", "ã‚ã‹ã‚Šã¾ã›ã‚“", "é›£ã—ã„", "è¿·ã†", "æ‚©ã‚€",
        "è€ƒãˆä¸­", "æ€ã„ã¤ã‹ãªã„", "ãƒ”ãƒ³ã¨ã“ãªã„", "ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ããªã„"
    ],
    # v10.22.1 æ–°è¦: çµ‚äº†ãƒ»ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³
    "exit": [
        "çµ‚äº†", "ã‚„ã‚ã‚‹", "ã‚„ã‚ãŸã„", "ã‚­ãƒ£ãƒ³ã‚»ãƒ«", "ä¸­æ­¢", "ä¸­æ–­",
        "ã‚„ã£ã±ã‚Šã„ã„", "ã¾ãŸä»Šåº¦", "å¾Œã§", "ä»Šæ—¥ã¯ã„ã„", "ã‚¹ãƒˆãƒƒãƒ—"
    ],
}

# v1.7 æ–°è¦: æ¥µç«¯ã«çŸ­ã„å›ç­”ã®é–¾å€¤
LENGTH_THRESHOLDS = {
    "extremely_short": 5,   # 5æ–‡å­—æœªæº€ã¯æ¥µç«¯ã«çŸ­ã„
    "very_short": 10,       # 10æ–‡å­—æœªæº€ã¯éå¸¸ã«çŸ­ã„
    "short": 20,            # 20æ–‡å­—æœªæº€ã¯çŸ­ã„
    "adequate": 30,         # 30æ–‡å­—ä»¥ä¸Šã¯é©åˆ‡
}

# v1.7 æ–°è¦: ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ã®æœŸå¾…ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
STEP_EXPECTED_KEYWORDS = {
    "why": {
        "positive": ["ãªã‚ŠãŸã„", "ã—ãŸã„", "ç›®æŒ‡", "å®Ÿç¾", "é”æˆ", "è²¢çŒ®"],
        "numeric": False,
        "deadline": False,
    },
    "what": {
        "positive": ["é”æˆ", "å®Œäº†", "ç²å¾—", "å¢—ã‚„ã™", "æ¸›ã‚‰ã™", "æ”¹å–„"],
        "numeric": True,   # æ•°å€¤ç›®æ¨™ãŒæœ›ã¾ã—ã„
        "deadline": True,  # æœŸé™ãŒæœ›ã¾ã—ã„
    },
    "how": {
        "positive": ["ã™ã‚‹", "ã‚„ã‚‹", "è¡Œã†", "å®Ÿæ–½", "æ¯æ—¥", "æ¯é€±", "é€±ã«", "æ—¥ã«"],
        "numeric": False,
        "deadline": False,
    },
}


class GoalSettingDialogue:
    """
    ç›®æ¨™è¨­å®šå¯¾è©±ãƒ•ãƒ­ãƒ¼ç®¡ç†ã‚¯ãƒ©ã‚¹

    ä¸€å•ä¸€ç­”å½¢å¼ã§ç›®æ¨™è¨­å®šã‚’ã‚¬ã‚¤ãƒ‰ã™ã‚‹ã€‚
    WHY â†’ WHAT â†’ HOW ã®é †ã§è³ªå•ã—ã€AIè©•ä¾¡ã‚’è¡Œã†ã€‚
    """

    def __init__(self, pool, room_id: str, account_id: str):
        """
        åˆæœŸåŒ–

        Args:
            pool: SQLAlchemy ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«
            room_id: ChatWorkãƒ«ãƒ¼ãƒ ID
            account_id: ChatWorkã‚¢ã‚«ã‚¦ãƒ³ãƒˆID
        """
        self.pool = pool
        self.room_id = str(room_id)
        self.account_id = str(account_id)
        self.user_id = None
        self.org_id = None
        self.user_name = None
        self.session = None

        # Phase 2.5 + B Memoryçµ±åˆ
        self.enriched_context = None
        self.pattern_analyzer = None

    def _get_user_info(self, conn) -> bool:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆv10.29.8: æ–‡å­—åˆ—å¤‰æ›å¯¾å¿œï¼‰"""
        result = conn.execute(
            text("""
                SELECT id, organization_id, name FROM users
                WHERE chatwork_account_id = :account_id
                LIMIT 1
            """),
            {"account_id": str(self.account_id)}
        ).fetchone()

        if not result:
            return False

        self.user_id = str(result[0])
        self.org_id = str(result[1]) if result[1] else None
        self.user_name = result[2] or "ãƒ¦ãƒ¼ã‚¶ãƒ¼"
        return True

    def _detect_frustration(self, message: str) -> bool:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä¸æº€ã‚’æ¤œå‡ºï¼ˆã€Œç­”ãˆãŸã˜ã‚ƒã‚“ã€ç­‰ï¼‰"""
        message_lower = message.lower()
        for pattern in FRUSTRATION_PATTERNS:
            if pattern in message_lower:
                return True
        return False

    def _extract_themes_from_message(self, message: str) -> Optional[str]:
        """
        v10.40.3: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ãƒ†ãƒ¼ãƒãƒ»é ˜åŸŸã‚’æŠ½å‡º

        ã€ŒSNSç™ºä¿¡ã¨AIé–‹ç™ºã¨çµ„ç¹”åŒ–ã€ã®ã‚ˆã†ãªè¤‡æ•°ãƒ†ãƒ¼ãƒã‚’
        ã€ŒSNSç™ºä¿¡ã€AIé–‹ç™ºã€çµ„ç¹”åŒ–ã€ã®å½¢å¼ã§è¿”ã™ã€‚

        Args:
            message: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

        Returns:
            æŠ½å‡ºã•ã‚ŒãŸãƒ†ãƒ¼ãƒï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰ã¾ãŸã¯None
        """
        # ã€Œã€œã¨ã€œã¨ã€œã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
        import re

        # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ã€ŒAã¨Bã¨Cã€å½¢å¼
        pattern1 = r'([^ã€‚ã€]+?)ã¨([^ã€‚ã€]+?)ã¨([^ã€‚ã€]+?)(?:ã«|ã‚’|ã®|ã§|ã¯|ãŒ)'
        match = re.search(pattern1, message)
        if match:
            return f"{match.group(1).strip()}ã€{match.group(2).strip()}ã€{match.group(3).strip()}"

        # ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã€ŒAãƒ»Bãƒ»Cã€å½¢å¼
        pattern2 = r'([^ã€‚ã€]+?)ãƒ»([^ã€‚ã€]+?)ãƒ»([^ã€‚ã€]+?)(?:ã«|ã‚’|ã®|ã§|ã¯|ãŒ)'
        match = re.search(pattern2, message)
        if match:
            return f"{match.group(1).strip()}ã€{match.group(2).strip()}ã€{match.group(3).strip()}"

        # ãƒ‘ã‚¿ãƒ¼ãƒ³3: ã€ŒAã€Bã€Cã€å½¢å¼
        pattern3 = r'([^ã€‚]+?)ã€([^ã€‚]+?)ã€([^ã€‚]+?)(?:ã«|ã‚’|ã®|ã§|ã¯|ãŒ)'
        match = re.search(pattern3, message)
        if match:
            return f"{match.group(1).strip()}ã€{match.group(2).strip()}ã€{match.group(3).strip()}"

        # ãƒ‘ã‚¿ãƒ¼ãƒ³4: ã€ŒAã¨Bã€å½¢å¼ï¼ˆ2ã¤ï¼‰
        pattern4 = r'([^ã€‚ã€]+?)ã¨([^ã€‚ã€]+?)(?:ã«|ã‚’|ã®|ã§|ã¯|ãŒ)'
        match = re.search(pattern4, message)
        if match:
            return f"{match.group(1).strip()}ã€{match.group(2).strip()}"

        # ãƒ†ãƒ¼ãƒã£ã½ã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚ã‚Œã°æŠ½å‡º
        theme_keywords = [
            "ç™ºä¿¡", "é–‹ç™º", "çµ„ç¹”", "å–¶æ¥­", "ãƒãƒ¼ã‚±", "æ¡ç”¨",
            "æ•™è‚²", "ç ”ä¿®", "ä¼ç”»", "è¨­è¨ˆ", "åˆ†æ", "æ”¹å–„",
        ]
        found_themes = []
        for kw in theme_keywords:
            if kw in message:
                # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚€æ–‡ç¯€ã‚’æŠ½å‡º
                idx = message.find(kw)
                start = max(0, idx - 5)
                end = min(len(message), idx + len(kw) + 5)
                snippet = message[start:end].strip()
                # é‡è¤‡ãƒã‚§ãƒƒã‚¯
                if snippet not in found_themes and len(snippet) < 20:
                    found_themes.append(snippet)

        if found_themes:
            return "ã€".join(found_themes[:3])  # æœ€å¤§3ã¤

        return None

    def _analyze_long_response_with_llm(self, message: str, session: Dict[str, Any]) -> Optional[Dict[str, str]]:
        """
        é•·æ–‡ã®å›ç­”ã‚’LLMã§è§£æã—ã¦WHY/WHAT/HOWã‚’æŠ½å‡º

        Returns:
            {"why": "...", "what": "...", "how": "..."} or None
        """
        if len(message) < LONG_RESPONSE_THRESHOLD:
            return None

        if not OPENROUTER_API_KEY:
            print("âš ï¸ OPENROUTER_API_KEYæœªè¨­å®šã®ãŸã‚LLMè§£æã‚’ã‚¹ã‚­ãƒƒãƒ—")
            return None

        # æ—¢ã«å›ç­”æ¸ˆã¿ã®éƒ¨åˆ†ã‚’è€ƒæ…®
        existing_why = session.get("why_answer", "")
        existing_what = session.get("what_answer", "")
        existing_how = session.get("how_answer", "")

        prompt = f"""ä»¥ä¸‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã‹ã‚‰ã€ç›®æ¨™è¨­å®šã®3è¦ç´ ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚

ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã€‘
{message}

ã€æ—¢ã«å›ç­”æ¸ˆã¿ã®å†…å®¹ã€‘
- WHYï¼ˆãªãœãƒ»å‹•æ©Ÿï¼‰: {existing_why or 'æœªå›ç­”'}
- WHATï¼ˆä½•ã‚’ãƒ»ç›®æ¨™ï¼‰: {existing_what or 'æœªå›ç­”'}
- HOWï¼ˆã©ã†ã‚„ã£ã¦ãƒ»è¡Œå‹•ï¼‰: {existing_how or 'æœªå›ç­”'}

ã€æŠ½å‡ºãƒ«ãƒ¼ãƒ«ã€‘
1. WHY: ãªãœãã®ç›®æ¨™ã‚’é”æˆã—ãŸã„ã®ã‹ï¼ˆå‹•æ©Ÿã€ãƒ“ã‚¸ãƒ§ãƒ³ã€æƒ³ã„ï¼‰
2. WHAT: å…·ä½“çš„ã«ä½•ã‚’é”æˆã—ãŸã„ã®ã‹ï¼ˆæ•°å€¤ç›®æ¨™ã€æˆæœã€ã‚´ãƒ¼ãƒ«ï¼‰
3. HOW: ã©ã‚“ãªè¡Œå‹•ã§é”æˆã™ã‚‹ã®ã‹ï¼ˆå…·ä½“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€ç¿’æ…£ï¼‰

ã€å‡ºåŠ›å½¢å¼ã€‘JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚è©²å½“ã™ã‚‹å†…å®¹ãŒãªã„å ´åˆã¯ç©ºæ–‡å­—ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚
{{"why": "æŠ½å‡ºã—ãŸå†…å®¹", "what": "æŠ½å‡ºã—ãŸå†…å®¹", "how": "æŠ½å‡ºã—ãŸå†…å®¹"}}"""

        try:
            with httpx.Client(timeout=LLM_TIMEOUT) as client:
                response = client.post(
                    "https://openrouter.ai/api/v1/chat/completions",
                    headers={
                        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                        "Content-Type": "application/json",
                    },
                    json={
                        "model": LLM_MODEL,
                        "messages": [{"role": "user", "content": prompt}],
                        "temperature": 0.3,
                    }
                )
                response.raise_for_status()
                result = response.json()
                content = result["choices"][0]["message"]["content"]

                # JSONã‚’æŠ½å‡º
                json_match = re.search(r'\{[^}]+\}', content, re.DOTALL)
                if json_match:
                    extracted = json.loads(json_match.group())
                    print(f"ğŸ§  LLMè§£æçµæœ: {extracted}")
                    return extracted

        except Exception as e:
            print(f"âš ï¸ LLMè§£æã‚¨ãƒ©ãƒ¼: {e}")

        return None

    def _generate_understanding_response(self, extracted: Dict[str, str], session: Dict[str, Any]) -> str:
        """æŠ½å‡ºã—ãŸå†…å®¹ã‚’å…ƒã«ã€ç†è§£ã‚’ç¤ºã™å¿œç­”ã‚’ç”Ÿæˆ"""
        why = extracted.get("why", "") or session.get("why_answer", "")
        what = extracted.get("what", "") or session.get("what_answer", "")
        how = extracted.get("how", "") or session.get("how_answer", "")

        response = f"""ğŸº {self.user_name}ã•ã‚“ã€ç†±ã„æƒ³ã„ã‚’èã‹ã›ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ï¼

ã‚½ã‚¦ãƒ«ãã‚“ãªã‚Šã«æ•´ç†ã—ã¦ã¿ãŸã‚¦ãƒ«ï¼š

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ ã€WHY - {self.user_name}ã•ã‚“ã®æƒ³ã„ã€‘
{why if why else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}

ğŸ¯ ã€WHAT - ç›®æŒ‡ã™ã‚´ãƒ¼ãƒ«ã€‘
{what if what else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}

ğŸ’ª ã€HOW - å…·ä½“çš„ãªè¡Œå‹•ã€‘
{how if how else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"""

        # è¶³ã‚Šãªã„éƒ¨åˆ†ã‚’ç¢ºèª
        missing = []
        if not why:
            missing.append("WHYï¼ˆãªãœãã‚Œã‚’ç›®æŒ‡ã™ã®ã‹ï¼‰")
        if not what:
            missing.append("WHATï¼ˆå…·ä½“çš„ãªæ•°å€¤ç›®æ¨™ï¼‰")
        if not how:
            missing.append("HOWï¼ˆæ¯æ—¥ãƒ»æ¯é€±ã®è¡Œå‹•ï¼‰")

        if missing:
            response += f"ã‚‚ã†å°‘ã—æ•™ãˆã¦ã»ã—ã„ã®ã¯ï¼š\n"
            for m in missing:
                response += f"  â“ {m}\n"
            response += f"\nã“ã®éƒ¨åˆ†ã‚’æ•™ãˆã¦ãã‚ŒãŸã‚‰ã€ç›®æ¨™ã¨ã—ã¦ç™»éŒ²ã§ãã‚‹ã‚¦ãƒ«ğŸºâœ¨"
        else:
            response += "ã“ã®ç†è§£ã§åˆã£ã¦ã‚‹ã‹ãªï¼Ÿ\n\nã€ŒOKã€ã¨è¨€ã£ã¦ãã‚ŒãŸã‚‰ç›®æ¨™ã¨ã—ã¦ç™»éŒ²ã™ã‚‹ã‚¦ãƒ«ï¼\nä¿®æ­£ãŒã‚ã‚Œã°æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨"

        return response

    def _generate_quality_check_response(
        self,
        session: Dict[str, Any],
        user_message: str,
        pattern_type: str
    ) -> str:
        """
        v10.40.2: å°ãã®å¯¾è©±ï¼ˆç›®æ¨™ã®è³ªãƒã‚§ãƒƒã‚¯ï¼‰å¿œç­”ã‚’ç”Ÿæˆ

        è¨­è¨ˆæ›¸ã«åŸºã¥ãã€å¿ƒç†çš„å®‰å…¨æ€§ã‚’ç¢ºä¿ã—ã¤ã¤ç›®æ¨™ã®è³ªã‚’é«˜ã‚ã‚‹è³ªå•ã‚’ç”Ÿæˆã€‚
        - WHY: å†…ç™ºçš„å‹•æ©Ÿï¼ˆèª°ãŒå–œã¶/ã©ã‚“ãªè‡ªåˆ†ã§ã„ãŸã„/ä½•ã‚’å¤§äº‹ã«ã—ãŸã„ï¼‰
        - WHAT: æ¸¬å®šå¯èƒ½ï¼ˆæ•°å­—/æœŸé™/å®šç¾©ãŒæ›–æ˜§ãªã‚‰å…·ä½“åŒ–ï¼‰
        - HOW: è¡Œå‹•ï¼ˆé »åº¦/é‡/æœ€åˆã®ä¸€æ­©/ä»Šé€±ã‚„ã‚‹ã“ã¨ï¼‰
        - éšœå®³: æƒ³å®šã•ã‚Œã‚‹éšœå®³ã¨å¯¾ç­–ã‚’1ã¤ã ã‘å•ã†

        NGå³å®ˆ: ã‚¸ãƒ£ãƒƒã‚¸ã§ã¯ãªãæ”¹å–„ã€è©°å•ç¦æ­¢
        """
        why = session.get("why_answer", "")
        what = session.get("what_answer", "")
        how = session.get("how_answer", "")

        # ç›®æ¨™ã®è³ªã‚’è©•ä¾¡ã—ã€è³ªå•ã‚’ç”Ÿæˆ
        quality_issues = []
        quality_questions = []

        # WHYã®è©•ä¾¡ï¼šå†…ç™ºçš„å‹•æ©ŸãŒè¦‹ãˆã‚‹ã‹
        if why:
            # å¤–ç™ºçš„å‹•æ©Ÿã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            external_patterns = ["è¨€ã‚ã‚ŒãŸ", "ã‚„ã‚‰ãªãã‚ƒ", "ã—ãªã‘ã‚Œã°", "ç¾©å‹™", "å‘½ä»¤", "æŒ‡ç¤º"]
            is_external = any(p in why for p in external_patterns)
            # å†…ç™ºçš„å‹•æ©Ÿã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            internal_patterns = ["ã—ãŸã„", "ãªã‚ŠãŸã„", "å®Ÿç¾", "å¤§åˆ‡", "å¤§äº‹", "å–œã¶", "å¹¸ã›"]
            has_internal = any(p in why for p in internal_patterns)

            if is_external and not has_internal:
                quality_issues.append("WHYã«å¤–ç™ºçš„å‹•æ©ŸãŒè¦‹ãˆã‚‹")
                quality_questions.append(
                    "ğŸ’­ ã“ã®ç›®æ¨™ã‚’é”æˆã—ãŸã‚‰ã€èª°ãŒå–œã¶ã‚¦ãƒ«ï¼Ÿãã—ã¦{user_name}ã•ã‚“è‡ªèº«ã¯ã©ã‚“ãªæ°—æŒã¡ã«ãªã‚‹ã‚¦ãƒ«ï¼Ÿ"
                )
            elif not has_internal and len(why) < 30:
                quality_issues.append("WHYãŒçŸ­ã„ãƒ»å†…ç™ºçš„å‹•æ©ŸãŒè–„ã„")
                quality_questions.append(
                    "ğŸ’­ ã‚‚ã†å°‘ã—èã‹ã›ã¦ã‚¦ãƒ«ã€‚ã“ã®ç›®æ¨™ã‚’é€šã˜ã¦ã€ã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ã‚¦ãƒ«ï¼Ÿ"
                )

        # WHATã®è©•ä¾¡ï¼šæ¸¬å®šå¯èƒ½ã‹
        if what:
            # æ•°å€¤ãƒ»æœŸé™ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            has_number = any(c.isdigit() for c in what)
            date_patterns = ["æœˆ", "æ—¥", "é€±", "å¹´", "ã¾ã§", "æœŸé™", "ç· åˆ‡"]
            has_date = any(p in what for p in date_patterns)

            if not has_number and not has_date:
                quality_issues.append("WHATã«æ•°å€¤ãƒ»æœŸé™ãŒãªã„")
                if len(quality_questions) < 2:
                    quality_questions.append(
                        "ğŸ¯ ã„ã¤ã¾ã§ã«ã€ã©ã®ãã‚‰ã„é”æˆã§ããŸã‚‰ã€Œã‚„ã£ãŸï¼ã€ã¨è¨€ãˆã‚‹ã‚¦ãƒ«ï¼Ÿ"
                    )

        # HOWã®è©•ä¾¡ï¼šå…·ä½“çš„ãªè¡Œå‹•ã‹
        if how:
            action_patterns = ["æ¯æ—¥", "æ¯é€±", "å›", "æ™‚é–“", "åˆ†", "ä»¶"]
            has_frequency = any(p in how for p in action_patterns)

            if not has_frequency:
                quality_issues.append("HOWã«é »åº¦ãƒ»é‡ãŒãªã„")
                if len(quality_questions) < 2:
                    quality_questions.append(
                        "ğŸ’ª æœ€åˆã®ä¸€æ­©ã¨ã—ã¦ã€ä»Šé€±ã¯ä½•ã‚’ã™ã‚‹ã‚¦ãƒ«ï¼Ÿå…·ä½“çš„ã«æ±ºã‚ã¦ãŠãã¨å‹•ãã‚„ã™ã„ã‚¦ãƒ«"
                    )

        # éšœå®³ã®è³ªå•ï¼ˆè³ªå•ãŒ1ã¤ä»¥ä¸‹ã®å ´åˆã®ã¿ï¼‰
        if len(quality_questions) < 2:
            quality_questions.append(
                "ğŸ¤” ã“ã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ä¸Šã§ã€ä¸€ç•ªã®å£ã«ãªã‚Šãã†ãªã“ã¨ã¯ä½•ã‚¦ãƒ«ï¼Ÿ"
            )

        # è³ªå•ã‚’æœ€å¤§2ã¤ã«åˆ¶é™
        quality_questions = quality_questions[:2]

        # å¿ƒç†çš„å®‰å…¨æ€§ã‚’ç¢ºä¿ã—ãŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
        if pattern_type == "feedback_request":
            quality_feedback = f"""ç¢ºèªã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ğŸº
ç›®æ¨™è¨­å®šã«ã€Œæ­£è§£ã€ã¯ãªã„ã‚¦ãƒ«ã€‚å¤§åˆ‡ãªã®ã¯{self.user_name}ã•ã‚“è‡ªèº«ãŒã€Œã“ã‚Œã§ã„ãï¼ã€ã¨æ€ãˆã‚‹ã“ã¨ã€‚

ãŸã ã€é”æˆç¢ºç‡ã‚’ä¸Šã’ã‚‹ãŸã‚ã«ã€ã‚½ã‚¦ãƒ«ãã‚“ã‹ã‚‰ã„ãã¤ã‹ç¢ºèªã•ã›ã¦ã‚¦ãƒ«ã€‚"""
        else:  # doubt_anxiety
            quality_feedback = f"""è¿·ã„ãŒã‚ã‚‹ã®ã€ã™ã”ãã‚ã‹ã‚‹ã‚¦ãƒ«ğŸº
ç›®æ¨™ã£ã¦ã€æœ€åˆã‹ã‚‰å®Œç’§ã˜ã‚ƒãªãã¦ã„ã„ã‚¦ãƒ«ã€‚èµ°ã‚ŠãªãŒã‚‰èª¿æ•´ã—ã¦ã„ã‘ã°OKã€‚

ã§ã‚‚ã›ã£ã‹ããªã®ã§ã€ã‚‚ã†å°‘ã—ã ã‘ä¸€ç·’ã«è€ƒãˆã•ã›ã¦ã‚¦ãƒ«ã€‚"""

        # è³ªå•ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
        questions_text = ""
        for i, q in enumerate(quality_questions, 1):
            questions_text += f"â“ è³ªå•{i}: {q.format(user_name=self.user_name)}\n"

        response = TEMPLATES["quality_check"].format(
            user_name=self.user_name,
            quality_feedback=quality_feedback,
            quality_questions=questions_text.strip()
        )

        return response

    def _get_active_session(self, conn) -> Optional[Dict[str, Any]]:
        """
        ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å–å¾—ï¼ˆv1.8: brain_conversation_statesä½¿ç”¨ï¼‰

        brain_conversation_states ã‹ã‚‰ state_type='goal_setting' ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ¤œç´¢ã€‚
        user_id ã¯ ChatWork account_id ã‚’ä½¿ç”¨ã€‚
        """
        result = conn.execute(
            text("""
                SELECT id, state_step, state_data, created_at, expires_at
                FROM brain_conversation_states
                WHERE user_id = :account_id
                  AND organization_id = :org_id
                  AND room_id = :room_id
                  AND state_type = 'goal_setting'
                  AND expires_at > CURRENT_TIMESTAMP
                ORDER BY created_at DESC
                LIMIT 1
            """),
            {
                "account_id": self.account_id,
                "org_id": self.org_id,
                "room_id": self.room_id
            }
        ).fetchone()

        if not result:
            return None

        # state_data ã‹ã‚‰ WHY/WHAT/HOW å›ç­”ã‚’å–å¾—
        state_data = result[2] or {}

        return {
            "id": str(result[0]),
            "current_step": result[1] or "why",
            "why_answer": state_data.get("why_answer"),
            "what_answer": state_data.get("what_answer"),
            "how_answer": state_data.get("how_answer"),
            "started_at": result[3],
            "expires_at": result[4]
        }

    def _create_session(self, conn) -> str:
        """
        æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆï¼ˆv1.8: brain_conversation_statesä½¿ç”¨ï¼‰

        v10.19.4: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯æœ€åˆã‹ã‚‰ 'why' ã‚¹ãƒ†ãƒƒãƒ—ã§ä½œæˆã™ã‚‹ã€‚
        'intro' ã¯è«–ç†çš„ãªã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦ã¯å­˜åœ¨ã›ãšã€ã‚¤ãƒ³ãƒˆãƒ­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡å¾Œã¯
        ã™ãã« WHY ã‚¹ãƒ†ãƒƒãƒ—ã«å…¥ã‚‹ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ€åˆã®è¿”ä¿¡ãŒ
        å¿…ãš WHY å›ç­”ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹ã€‚

        v1.8: brain_conversation_states ã«çŠ¶æ…‹ã‚’ä½œæˆã€‚
        user_id ã«ã¯ ChatWork account_id ã‚’ä½¿ç”¨ã€‚
        """
        # v10.40.4: UPSERTä¿®æ­£ - æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å›ç­”ã‚’ä¿è­·
        # INSERTæ™‚ã®ã¿ state_step='why', state_data='{}' ã‚’è¨­å®š
        # UPDATEæ™‚ã¯ expires_at ã¨ updated_at ã®ã¿æ›´æ–°ï¼ˆå›ç­”ã‚’ä¸Šæ›¸ãã—ãªã„ï¼‰
        result = conn.execute(
            text("""
                INSERT INTO brain_conversation_states (
                    organization_id, room_id, user_id,
                    state_type, state_step, state_data,
                    expires_at, timeout_minutes,
                    created_at, updated_at
                ) VALUES (
                    :org_id, :room_id, :account_id,
                    'goal_setting', 'why', '{}',
                    CURRENT_TIMESTAMP + INTERVAL '24 hours', 1440,
                    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                )
                ON CONFLICT (organization_id, room_id, user_id)
                DO UPDATE SET
                    expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
                    updated_at = CURRENT_TIMESTAMP
                RETURNING id
            """),
            {
                "org_id": self.org_id,
                "room_id": self.room_id,
                "account_id": self.account_id
            }
        )
        row = result.fetchone()
        session_id = str(row[0]) if row else str(uuid4())
        conn.commit()
        return session_id

    def _clear_session(self, conn, session_id: str) -> None:
        """
        ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢ï¼ˆv10.40.3: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆç”¨ï¼‰

        æ˜ç¤ºçš„ãªãƒªã‚¹ã‚¿ãƒ¼ãƒˆè¦æ±‚æ™‚ã«ä½¿ç”¨ã€‚
        brain_conversation_states ã‹ã‚‰å‰Šé™¤ã—ã¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã€‚
        """
        conn.execute(
            text("""
                DELETE FROM brain_conversation_states
                WHERE id = :session_id
            """),
            {"session_id": session_id}
        )
        conn.commit()
        print(f"   âœ… Session cleared: {session_id}")

    def _update_session(self, conn, session_id: str,
                       current_step: str = None,
                       why_answer: str = None,
                       what_answer: str = None,
                       how_answer: str = None,
                       status: str = None,
                       goal_id: str = None) -> None:
        """
        ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ›´æ–°ï¼ˆv1.8: brain_conversation_statesä½¿ç”¨ï¼‰

        state_data JSONBã« WHY/WHAT/HOW å›ç­”ã‚’æ ¼ç´ã€‚
        status='completed' ã®å ´åˆã¯çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ï¼ˆDELETEã§ã¯ãªãstate_typeæ›´æ–°ï¼‰ã€‚
        """
        # ã¾ãšç¾åœ¨ã®state_dataã‚’å–å¾—
        current = conn.execute(
            text("""
                SELECT state_data FROM brain_conversation_states
                WHERE id = :session_id
            """),
            {"session_id": session_id}
        ).fetchone()

        current_data = (current[0] if current and current[0] else {}) or {}

        # state_dataã‚’æ›´æ–°
        if why_answer is not None:
            current_data["why_answer"] = why_answer
        if what_answer is not None:
            current_data["what_answer"] = what_answer
        if how_answer is not None:
            current_data["how_answer"] = how_answer
        if goal_id is not None:
            current_data["goal_id"] = goal_id

        # æ›´æ–°ã‚¯ã‚¨ãƒªã‚’æ§‹ç¯‰
        updates = ["updated_at = CURRENT_TIMESTAMP"]
        params = {"session_id": session_id, "state_data": json.dumps(current_data)}

        # v10.40.7: status='completed' ã®å ´åˆã¯ state_step ã‚’ NULL ã«è¨­å®šã™ã‚‹ãŸã‚ã€
        # current_step ã®è¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆäºŒé‡è¨­å®šã«ã‚ˆã‚‹SQLæ–‡æ³•ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
        if status == "completed":
            updates.append("state_type = 'normal'")
            updates.append("state_step = NULL")
            current_data["completed_at"] = datetime.utcnow().isoformat()
            params["state_data"] = json.dumps(current_data)
        elif current_step is not None:
            updates.append("state_step = :current_step")
            params["current_step"] = current_step

        updates.append("state_data = CAST(:state_data AS jsonb)")

        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå»¶é•·
        updates.append("expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours'")

        conn.execute(
            text(f"UPDATE brain_conversation_states SET {', '.join(updates)} WHERE id = :session_id"),
            params
        )
        conn.commit()

    def _log_interaction(self, conn, session_id: str, step: str,
                        user_message: str, ai_response: str,
                        detected_pattern: str = None,
                        evaluation_result: dict = None,
                        feedback_given: bool = False,
                        result: str = None,
                        step_attempt: int = 1) -> None:
        """
        å¯¾è©±ãƒ­ã‚°ã‚’è¨˜éŒ²ï¼ˆv1.8: brain_dialogue_logsä½¿ç”¨ï¼‰

        å…¨å¯¾è©±ãƒ•ãƒ­ãƒ¼ã®ãƒ­ã‚°ã‚’çµ±ä¸€ç®¡ç†ã™ã‚‹brain_dialogue_logsã«è¨˜éŒ²ã€‚
        chatwork_account_id ã‚’ä½¿ç”¨ã€‚
        """
        log_id = str(uuid4())
        conn.execute(
            text("""
                INSERT INTO brain_dialogue_logs (
                    id, organization_id, chatwork_account_id, room_id,
                    state_type, state_step, step_attempt,
                    user_message, ai_response,
                    detected_pattern, evaluation_result, feedback_given, result
                ) VALUES (
                    :id, :org_id, :account_id, :room_id,
                    'goal_setting', :step, :step_attempt,
                    :user_message, :ai_response,
                    :detected_pattern, :evaluation_result, :feedback_given, :result
                )
            """),
            {
                "id": log_id,
                "org_id": self.org_id,
                "account_id": self.account_id,
                "room_id": self.room_id,
                "step": step,
                "step_attempt": step_attempt,
                "user_message": user_message,
                "ai_response": ai_response,
                "detected_pattern": detected_pattern,
                "evaluation_result": json.dumps(evaluation_result) if evaluation_result else None,
                "feedback_given": feedback_given,
                "result": result
            }
        )
        conn.commit()

    def _get_step_attempt_count(self, conn, session_id: str, step: str) -> int:
        """
        ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã®è©¦è¡Œå›æ•°ã‚’å–å¾—ï¼ˆv1.8: brain_dialogue_logsä½¿ç”¨ï¼‰

        chatwork_account_idã¨room_idã§æ¤œç´¢ã€‚session_idã¯ä½¿ç”¨ã—ãªã„ã€‚
        """
        result = conn.execute(
            text("""
                SELECT COUNT(*) FROM brain_dialogue_logs
                WHERE chatwork_account_id = :account_id
                  AND room_id = :room_id
                  AND organization_id = :org_id
                  AND state_type = 'goal_setting'
                  AND state_step = :step
                  AND created_at > CURRENT_TIMESTAMP - INTERVAL '24 hours'
            """),
            {
                "account_id": self.account_id,
                "room_id": self.room_id,
                "org_id": self.org_id,
                "step": step
            }
        ).fetchone()
        return (result[0] or 0) + 1

    def _detect_pattern(self, message: str, step: str,
                        context: Dict[str, Any] = None) -> Tuple[str, Dict[str, Any]]:
        """
        ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºï¼ˆv1.7 æ‹¡å¼µç‰ˆï¼‰

        ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®æ¤œå‡º + æ–‡è„ˆè€ƒæ…®ã€‚
        å°†æ¥çš„ã«ã¯AIè©•ä¾¡ã¨ã®ä½µç”¨ã‚’äºˆå®šã€‚

        Args:
            message: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            step: ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ— ('why', 'what', 'how')
            context: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã€ãƒªãƒˆãƒ©ã‚¤å›æ•°ãªã©ï¼‰

        Returns:
            (pattern_code, evaluation_result)
        """
        context = context or {}
        message_lower = message.lower()
        message_length = len(message.strip())

        evaluation = {
            "detected_keywords": [],
            "specificity_score": 0.0,
            "issues": [],
            "message_length": message_length,
            "is_question": False,
            "is_confused": False,
            "retry_count": context.get("retry_count", 0),
        }

        # =====================================================
        # Phase 1: å„ªå…ˆåº¦æœ€é«˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º
        # =====================================================

        # 1-1. ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ˜ãƒ«ã‚¹æ‡¸å¿µã¯æœ€å„ªå…ˆã§ãƒã‚§ãƒƒã‚¯
        for keyword in PATTERN_KEYWORDS["ng_mental_health"]:
            if keyword in message:
                evaluation["detected_keywords"].append(keyword)
                evaluation["issues"].append("mental_health_concern")
                return "ng_mental_health", evaluation

        # =====================================================
        # Phase 2: v1.7æ–°è¦ - è³ªå•ãƒ»ãƒ˜ãƒ«ãƒ—è¦æ±‚ã®æ¤œå‡º
        # =====================================================

        # 2-1. è³ªå•å½¢å¼ã®æ¤œå‡ºï¼ˆï¼Ÿã§çµ‚ã‚ã‚‹ï¼‰
        if message.strip().endswith("ï¼Ÿ") or message.strip().endswith("?"):
            evaluation["is_question"] = True
            evaluation["issues"].append("question_detected")
            # è³ªå•ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚‚ãƒã‚§ãƒƒã‚¯
            for keyword in PATTERN_KEYWORDS["help_question"]:
                if keyword in message:
                    evaluation["detected_keywords"].append(keyword)
            return f"help_question_{step}", evaluation

        # 2-2. ãƒ˜ãƒ«ãƒ—è¦æ±‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
        for keyword in PATTERN_KEYWORDS["help_question"]:
            if keyword in message:
                evaluation["detected_keywords"].append(keyword)
                evaluation["is_question"] = True

        if evaluation["is_question"]:
            evaluation["issues"].append("help_request")
            return f"help_question_{step}", evaluation

        # 2-3. å›°æƒ‘ãƒ»è¿·ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºï¼ˆå…¨ã‚¹ãƒ†ãƒƒãƒ—å…±é€šï¼‰
        for keyword in PATTERN_KEYWORDS["help_confused"]:
            if keyword in message:
                evaluation["detected_keywords"].append(keyword)
                evaluation["is_confused"] = True

        if evaluation["is_confused"]:
            evaluation["issues"].append("confused")
            return f"help_confused_{step}", evaluation

        # =====================================================
        # Phase 3: æ—¢å­˜ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼ˆå„ªå…ˆåº¦é †ï¼‰ - é•·ã•ãƒã‚§ãƒƒã‚¯ã‚ˆã‚Šå…ˆã«å®Ÿè¡Œ
        # =====================================================

        # å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¦ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã¯çŸ­ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚‚æ¤œå‡ºã™ã‚‹ï¼‰
        for pattern, keywords in PATTERN_KEYWORDS.items():
            if pattern in ["ng_mental_health", "help_question", "help_confused"]:
                continue  # æ—¢ã«ãƒã‚§ãƒƒã‚¯æ¸ˆã¿

            for keyword in keywords:
                if keyword in message:
                    evaluation["detected_keywords"].append(keyword)

        # æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ¤å®š
        if evaluation["detected_keywords"]:
            detected_patterns = []
            for pattern, keywords in PATTERN_KEYWORDS.items():
                if pattern in ["help_question", "help_confused"]:
                    continue
                if any(kw in evaluation["detected_keywords"] for kw in keywords):
                    detected_patterns.append(pattern)

            evaluation["issues"].extend(detected_patterns)

            # å„ªå…ˆåº¦é †ã«è¿”ã™ï¼ˆé‡è¦ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å…ˆã«ï¼‰
            # 1. è»¢è·ãƒ»å‰¯æ¥­å¿—å‘ï¼ˆWHYã‚¹ãƒ†ãƒƒãƒ—ã®ã¿ï¼‰
            if step == "why" and "ng_career" in detected_patterns:
                return "ng_career", evaluation
            # 2. ä»–è²¬æ€è€ƒ
            if "ng_other_blame" in detected_patterns:
                return "ng_other_blame", evaluation
            # 3. ç›®æ¨™ãŒãªã„ï¼ˆWHYã‚¹ãƒ†ãƒƒãƒ—ã®ã¿ - ã€Œã‚ã‹ã‚‰ãªã„ã€ã¯help_confusedã§å‡¦ç†ï¼‰
            if step == "why" and "ng_no_goal" in detected_patterns:
                return "ng_no_goal", evaluation
            # 4. ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆç›®æ¨™ã®ã¿ï¼ˆWHY/WHATã‚¹ãƒ†ãƒƒãƒ—ï¼‰
            if step in ["why", "what"] and "ng_private_only" in detected_patterns:
                return "ng_private_only", evaluation
            # 5. æŠ½è±¡çš„ã™ãã‚‹ï¼ˆãŸã ã—æ¥µç«¯ã«çŸ­ã„å ´åˆã¯too_shortã‚’å„ªå…ˆï¼‰
            if "ng_abstract" in detected_patterns:
                if message_length >= LENGTH_THRESHOLDS["very_short"]:
                    return "ng_abstract", evaluation

        # =====================================================
        # Phase 4: v1.7æ–°è¦ - æ¥µç«¯ã«çŸ­ã„å›ç­”ã®æ¤œå‡º
        # â€» é‡è¦ãªãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã®å¾Œã«å®Ÿè¡Œ
        # =====================================================

        if message_length < LENGTH_THRESHOLDS["extremely_short"]:
            # 5æ–‡å­—æœªæº€ã¯æ¥µç«¯ã«çŸ­ã„
            evaluation["issues"].append("extremely_short")
            evaluation["specificity_score"] = 0.1
            return "too_short", evaluation

        if message_length < LENGTH_THRESHOLDS["very_short"]:
            # 5-10æ–‡å­—ã¯éå¸¸ã«çŸ­ã„
            evaluation["issues"].append("very_short")
            evaluation["specificity_score"] = 0.2
            return "too_short", evaluation

        # =====================================================
        # Phase 5: v1.7å¼·åŒ– - å…·ä½“æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
        # =====================================================

        specificity_score = self._calculate_specificity_score(message, step)
        evaluation["specificity_score"] = specificity_score

        # ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ã®å…·ä½“æ€§ãƒã‚§ãƒƒã‚¯
        if step == "what":
            # WHATã¯æ•°å€¤ç›®æ¨™ãŒæœ›ã¾ã—ã„
            has_numbers = bool(re.search(r'\d+', message))
            has_deadline = self._has_deadline_expression(message)

            if not has_numbers and message_length < LENGTH_THRESHOLDS["short"]:
                evaluation["issues"].append("too_abstract")
                evaluation["issues"].append("no_numeric_target")
                return "ng_abstract", evaluation

        elif step == "how":
            # HOWã¯å…·ä½“çš„ãªè¡Œå‹•ãŒæœ›ã¾ã—ã„
            has_action = self._has_action_expression(message)

            if not has_action and message_length < LENGTH_THRESHOLDS["short"]:
                evaluation["issues"].append("too_abstract")
                evaluation["issues"].append("no_action_verb")
                return "ng_abstract", evaluation

        # =====================================================
        # Phase 6: å•é¡Œãªã—
        # =====================================================
        return "ok", evaluation

    def _calculate_specificity_score(self, message: str, step: str) -> float:
        """
        å…·ä½“æ€§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆv1.7æ–°è¦ï¼‰

        0.0 ã€œ 1.0 ã®ã‚¹ã‚³ã‚¢ã‚’è¿”ã™ã€‚

        è¨ˆç®—è¦ç´ :
        - æ–‡å­—æ•°ï¼ˆé•·ã„ã»ã©é«˜ã„ã€ä¸Šé™ã‚ã‚Šï¼‰
        - æ•°å€¤è¡¨ç¾ã®æœ‰ç„¡
        - æœŸé™è¡¨ç¾ã®æœ‰ç„¡
        - è¡Œå‹•å‹•è©ã®æœ‰ç„¡ï¼ˆHOWã‚¹ãƒ†ãƒƒãƒ—ï¼‰
        - ã‚¹ãƒ†ãƒƒãƒ—åˆ¥æœŸå¾…ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®æœ‰ç„¡
        """
        score = 0.0
        message_length = len(message.strip())

        # 1. æ–‡å­—æ•°ã‚¹ã‚³ã‚¢ï¼ˆæœ€å¤§0.3ï¼‰
        if message_length >= LENGTH_THRESHOLDS["adequate"]:
            score += 0.3
        elif message_length >= LENGTH_THRESHOLDS["short"]:
            score += 0.2
        elif message_length >= LENGTH_THRESHOLDS["very_short"]:
            score += 0.1

        # 2. æ•°å€¤è¡¨ç¾ã‚¹ã‚³ã‚¢ï¼ˆæœ€å¤§0.2ï¼‰
        if bool(re.search(r'\d+', message)):
            score += 0.2

        # 3. æœŸé™è¡¨ç¾ã‚¹ã‚³ã‚¢ï¼ˆæœ€å¤§0.2ï¼‰
        if self._has_deadline_expression(message):
            score += 0.2

        # 4. ã‚¹ãƒ†ãƒƒãƒ—åˆ¥æœŸå¾…ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢ï¼ˆæœ€å¤§0.2ï¼‰
        if step in STEP_EXPECTED_KEYWORDS:
            expected = STEP_EXPECTED_KEYWORDS[step]
            if any(kw in message for kw in expected["positive"]):
                score += 0.2

        # 5. è¡Œå‹•å‹•è©ã‚¹ã‚³ã‚¢ï¼ˆHOWã‚¹ãƒ†ãƒƒãƒ—ã®ã¿ã€æœ€å¤§0.1ï¼‰
        if step == "how" and self._has_action_expression(message):
            score += 0.1

        return min(score, 1.0)

    def _has_deadline_expression(self, message: str) -> bool:
        """æœŸé™è¡¨ç¾ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆv1.7æ–°è¦ï¼‰"""
        deadline_patterns = [
            r'\d+æœˆ', r'\d+æ—¥', r'\d+é€±',  # æ•°å­—+å˜ä½
            r'ä»Šæœˆ', r'æ¥æœˆ', r'ä»Šé€±', r'æ¥é€±',  # ç›¸å¯¾æœŸé™
            r'æœˆæœ«', r'é€±æœ«', r'å¹´æœ«', r'æœŸæœ«',  # æœŸé™è¡¨ç¾
            r'ã¾ã§', r'æœŸé™', r'ç· ã‚åˆ‡ã‚Š', r'ç· åˆ‡',  # æœŸé™ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            r'ã€œã¾ã§ã«', r'ï½ã¾ã§ã«',  # ãƒ‘ã‚¿ãƒ¼ãƒ³
        ]
        return any(re.search(pattern, message) for pattern in deadline_patterns)

    def _has_action_expression(self, message: str) -> bool:
        """è¡Œå‹•è¡¨ç¾ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆv1.7æ–°è¦ï¼‰"""
        action_patterns = [
            r'ã™ã‚‹', r'ã‚„ã‚‹', r'è¡Œã†', r'å®Ÿæ–½',
            r'æ¯æ—¥', r'æ¯é€±', r'æ¯æœ', r'æ¯æ™©',
            r'é€±ã«\d+', r'æ—¥ã«\d+', r'æœˆã«\d+',
            r'\d+å›', r'\d+ä»¶', r'\d+åˆ†',
            r'ç¶šã‘ã‚‹', r'ç¿’æ…£', r'ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³',
        ]
        return any(re.search(pattern, message) for pattern in action_patterns)

    def _register_goal(self, conn, session: Dict[str, Any]) -> str:
        """
        ç›®æ¨™ã‚’goalsãƒ†ãƒ¼ãƒ–ãƒ«ã«ç™»éŒ²

        Returns:
            goal_id
        """
        goal_id = str(uuid4())
        today = date.today()

        # æœˆæœ«ã‚’è¨ˆç®—
        if today.month == 12:
            period_end = today.replace(year=today.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            period_end = today.replace(month=today.month + 1, day=1) - timedelta(days=1)

        # WHATå›ç­”ã‹ã‚‰ç›®æ¨™ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºï¼ˆæœ€åˆã®50æ–‡å­—ï¼‰
        what_answer = session.get("what_answer", "")
        goal_title = what_answer[:50] if len(what_answer) > 50 else what_answer

        # æ•°å€¤ç›®æ¨™ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        numbers = re.findall(r'[\d,]+(?:ä¸‡|å„„|åƒ)?(?:å††|ä»¶|å€‹|å›|%)?', what_answer)
        target_value = None
        unit = None
        goal_type = "action"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯è¡Œå‹•ç›®æ¨™

        if numbers:
            # æœ€åˆã®æ•°å€¤ã‚’æŠ½å‡º
            num_str = numbers[0]
            # å˜ä½ã‚’æŠ½å‡º
            unit_match = re.search(r'(å††|ä»¶|å€‹|å›|%|ä¸‡|å„„)$', num_str)
            if unit_match:
                unit = unit_match.group(1)
                num_str = num_str[:-len(unit)]

            # æ•°å€¤ã‚’å¤‰æ›
            try:
                num_str = num_str.replace(",", "")
                target_value = float(num_str)
                if "ä¸‡" in (unit or ""):
                    target_value *= 10000
                    unit = "å††"
                elif "å„„" in (unit or ""):
                    target_value *= 100000000
                    unit = "å††"
                goal_type = "numeric"
            except ValueError:
                pass

        conn.execute(
            text("""
                INSERT INTO goals (
                    id, organization_id, user_id, goal_level, title, description,
                    goal_type, target_value, current_value, unit, deadline,
                    period_type, period_start, period_end, status, classification,
                    created_by, updated_by, created_at, updated_at
                ) VALUES (
                    :id, :org_id, :user_id, 'individual', :title, :description,
                    :goal_type, :target_value, 0, :unit, NULL,
                    'monthly', :period_start, :period_end, 'active', 'internal',
                    :user_id, :user_id, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                )
            """),
            {
                "id": goal_id,
                "org_id": self.org_id,
                "user_id": self.user_id,
                "title": goal_title,
                "description": f"WHY: {session.get('why_answer', '')}\nWHAT: {what_answer}\nHOW: {session.get('how_answer', '')}",
                "goal_type": goal_type,
                "target_value": target_value,
                "unit": unit,
                "period_start": today.replace(day=1),
                "period_end": period_end
            }
        )
        conn.commit()
        return goal_id

    def start_or_continue(self, user_message: str = None) -> Dict[str, Any]:
        """
        ç›®æ¨™è¨­å®šå¯¾è©±ã‚’é–‹å§‹ã¾ãŸã¯ç¶™ç¶š

        Args:
            user_message: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆç¶™ç¶šæ™‚ã®ã¿ï¼‰

        Returns:
            {"success": bool, "message": str, "session_id": str, "step": str}
        """
        print(f"ğŸ¯ GoalSettingDialogue.start_or_continue: room_id={self.room_id}, account_id={self.account_id}")

        with self.pool.connect() as conn:
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
            if not self._get_user_info(conn):
                return {
                    "success": False,
                    "message": "ğŸ¤” ã¾ã ã‚½ã‚¦ãƒ«ãã‚“ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„ã¿ãŸã„ã‚¦ãƒ«ï¼\n\nç®¡ç†è€…ã«é€£çµ¡ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’ãŠé¡˜ã„ã—ã¦ã‚¦ãƒ«ğŸº"
                }

            if not self.org_id:
                return {
                    "success": False,
                    "message": "ğŸ¤” çµ„ç¹”æƒ…å ±ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã¿ãŸã„ã‚¦ãƒ«ï¼\n\nç®¡ç†è€…ã«é€£çµ¡ã—ã¦ã€çµ„ç¹”è¨­å®šã‚’ãŠé¡˜ã„ã—ã¦ã‚¦ãƒ«ğŸº"
                }

            # Phase 2.5 + B Memoryçµ±åˆ: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
            self._load_memory_context(conn)

            # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¢ºèª
            session = self._get_active_session(conn)

            # v10.40.3: æ˜ç¤ºçš„ãƒªã‚¹ã‚¿ãƒ¼ãƒˆè¦æ±‚ã®ãƒã‚§ãƒƒã‚¯
            # æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã£ã¦ã‚‚ã€ã€Œã‚„ã‚Šç›´ã—ãŸã„ã€ç­‰ã®å ´åˆã¯ãƒªã‚»ãƒƒãƒˆ
            if session is not None and user_message and _wants_restart(user_message):
                print(f"   ğŸ”„ Restart requested: clearing existing session {session['id']}")
                self._clear_session(conn, session["id"])
                session = None  # æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã¸

            if session is None:
                # æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ï¼ˆv10.19.4: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯æœ€åˆã‹ã‚‰ 'why' ã§ä½œæˆï¼‰
                session_id = self._create_session(conn)

                # å°å…¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ï¼ˆWHYè³ªå•ã‚’å«ã‚€ï¼‰
                intro_message = TEMPLATES["intro"].format(user_name=self.user_name)

                # ãƒ­ã‚°ã‚’è¨˜éŒ²ï¼ˆå±¥æ­´ç›®çš„ã§ 'intro' ã¨ã—ã¦è¨˜éŒ²ï¼‰
                self._log_interaction(
                    conn, session_id, "intro",
                    user_message or "ç›®æ¨™ã‚’è¨­å®šã—ãŸã„",
                    intro_message,
                    detected_pattern="ok",
                    result="accepted",
                    step_attempt=1
                )

                # v10.19.4: _update_session() å‘¼ã³å‡ºã—ã‚’å‰Šé™¤
                # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯æœ€åˆã‹ã‚‰ 'why' ã§ä½œæˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€
                # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¬¡ã®è¿”ä¿¡ã¯ WHY å›ç­”ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹

                return {
                    "success": True,
                    "message": intro_message,
                    "session_id": session_id,
                    "step": "why"  # v10.19.4: intro ã‹ã‚‰ why ã«å¤‰æ›´
                }

            # æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¶™ç¶š
            return self._process_step(conn, session, user_message)

    def _process_step(self, conn, session: Dict[str, Any], user_message: str) -> Dict[str, Any]:
        """
        ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å‡¦ç†ï¼ˆv1.7æ‹¡å¼µï¼‰
        """
        session_id = session["id"]
        current_step = session["current_step"]
        step_attempt = self._get_step_attempt_count(conn, session_id, current_step)

        print(f"   Processing step: {current_step}, attempt: {step_attempt}")

        if not user_message:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãªã„å ´åˆã¯ç¾åœ¨ã®è³ªå•ã‚’å†è¡¨ç¤º
            return self._get_current_question(session)

        # v10.22.1: çµ‚äº†ã‚³ãƒãƒ³ãƒ‰ã®ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
        for exit_keyword in PATTERN_KEYWORDS["exit"]:
            if exit_keyword in user_message:
                print(f"   Exit keyword detected: {exit_keyword}")
                response = TEMPLATES["exit"].format(user_name=self.user_name)
                self._log_interaction(
                    conn, session_id, current_step,
                    user_message, response,
                    detected_pattern="exit",
                    result="abandoned",  # DB constraint: accepted, retry, abandoned
                    step_attempt=step_attempt
                )
                # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ï¼ˆDB constraint: in_progress, completed, abandonedï¼‰
                self._update_session(conn, session_id, current_step=current_step, status="abandoned")
                return {
                    "success": True,
                    "message": response,
                    "session_id": session_id,
                    "step": current_step,
                    "pattern": "exit"
                }

        # =====================================================
        # v10.31.5: ç¢ºèªã‚¹ãƒ†ãƒƒãƒ—ã®å‡¦ç†ï¼ˆLLMæŠ½å‡ºå¾Œï¼‰
        # =====================================================
        if current_step == "confirm":
            print(f"   ğŸ“‹ ç¢ºèªã‚¹ãƒ†ãƒƒãƒ—: ãƒ¦ãƒ¼ã‚¶ãƒ¼å¿œç­”ã€Œ{user_message[:30]}...ã€")

            # OKãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆv10.40.1: ç´”ç²‹ãªç¢ºèªã®ã¿å—ã‘ä»˜ã‘ã‚‹ï¼‰
            # ã€Œåˆã£ã¦ã‚‹ã‘ã©ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã—ã¦ã€ã®ã‚ˆã†ãªå¦å®šæ¥ç¶šã‚„FBè¦æ±‚ã¯ç¢ºèªã¨ã¿ãªã•ãªã„
            is_confirmed = _is_pure_confirmation(user_message)

            if is_confirmed:
                print(f"   âœ… ç¢ºèªOK - ç›®æ¨™ã‚’ç™»éŒ²ã—ã¾ã™")
                # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ä¿å­˜æ¸ˆã¿ã®å›ç­”ã‚’å–å¾—
                why_answer = session.get("why_answer", "")
                what_answer = session.get("what_answer", "")
                how_answer = session.get("how_answer", "")

                # ç›®æ¨™ç™»éŒ²
                goal_id = self._register_goal(conn, session)
                self._update_session(
                    conn, session_id,
                    current_step="complete",
                    status="completed",
                    goal_id=goal_id
                )

                response = TEMPLATES["complete"].format(
                    user_name=self.user_name,
                    why_answer=why_answer,
                    what_answer=what_answer,
                    how_answer=how_answer
                )

                self._log_interaction(
                    conn, session_id, "confirm",
                    user_message, response,
                    detected_pattern="confirmed",
                    result="accepted",
                    step_attempt=step_attempt
                )

                # Phase 2.5 + B Memoryçµ±åˆ: ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã®å­¦ç¿’
                self._update_session_stats_on_complete(conn, session)

                return {
                    "success": True,
                    "message": response,
                    "session_id": session_id,
                    "step": "complete",
                    "pattern": "confirmed"
                }
            else:
                # v10.40.2: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¦æ±‚/è¿·ã„ãƒ»ä¸å®‰ã®å ´åˆã¯ã€Œå°ãã®å¯¾è©±ã€ã¸
                is_feedback_request = _has_feedback_request(user_message)
                is_doubt_anxiety = _has_doubt_or_anxiety(user_message)

                if is_feedback_request or is_doubt_anxiety:
                    # å°ãã®å¯¾è©±ï¼ˆç›®æ¨™ã®è³ªãƒã‚§ãƒƒã‚¯ï¼‰
                    pattern_type = "feedback_request" if is_feedback_request else "doubt_anxiety"
                    print(f"   ğŸ’¡ å°ãã®å¯¾è©±ã¸: {pattern_type}")

                    response = self._generate_quality_check_response(
                        session, user_message, pattern_type
                    )

                    self._log_interaction(
                        conn, session_id, "confirm",
                        user_message, response,
                        detected_pattern=pattern_type,
                        result="quality_check",
                        step_attempt=step_attempt
                    )

                    return {
                        "success": True,
                        "message": response,
                        "session_id": session_id,
                        "step": "confirm",
                        "pattern": pattern_type
                    }

                # =====================================================
                # v10.40.6: confirmç„¡é™ãƒ«ãƒ¼ãƒ—å®Œå…¨é˜²æ­¢ãƒ‘ãƒƒãƒ
                # =====================================================
                # ãƒ«ãƒ¼ãƒ«:
                # - é•·æ–‡ ã‹ã¤ LLMæŠ½å‡ºæˆåŠŸ ã‹ã¤ æœ‰åŠ¹ãªä¿®æ­£ã‚ã‚Š â†’ è¦ç´„æ›´æ–°
                # - ãã‚Œä»¥å¤–ã¯å…¨ã¦ â†’ å°ãã®å¯¾è©±ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                # - ã€ŒåŒã˜è¦ç´„ã‚’å†è¡¨ç¤ºã€ã¯çµ¶å¯¾ã«ã—ãªã„
                # =====================================================

                print(f"   ğŸ”„ å…¥åŠ›ã‚’åˆ†æä¸­...")

                # é•·æ–‡ã®å ´åˆã®ã¿LLMã§ä¿®æ­£è§£æã‚’è©¦ã¿ã‚‹
                if len(user_message) >= LONG_RESPONSE_THRESHOLD:
                    extracted = self._analyze_long_response_with_llm(user_message, session)

                    # æœ‰åŠ¹ãªä¿®æ­£ãŒæŠ½å‡ºã§ããŸå ´åˆã®ã¿è¦ç´„ã‚’æ›´æ–°
                    has_valid_updates = (
                        extracted and
                        (extracted.get("why") or extracted.get("what") or extracted.get("how"))
                    )

                    if has_valid_updates:
                        # ä¿®æ­£å†…å®¹ã‚’æ›´æ–°
                        updates = {}
                        if extracted.get("why"):
                            updates["why_answer"] = extracted["why"]
                            session["why_answer"] = extracted["why"]
                        if extracted.get("what"):
                            updates["what_answer"] = extracted["what"]
                            session["what_answer"] = extracted["what"]
                        if extracted.get("how"):
                            updates["how_answer"] = extracted["how"]
                            session["how_answer"] = extracted["how"]

                        self._update_session(conn, session_id, **updates)

                        # ä¿®æ­£å¾Œã®å†…å®¹ã§å†ç¢ºèª
                        response = self._generate_understanding_response(
                            {"why": session.get("why_answer", ""),
                             "what": session.get("what_answer", ""),
                             "how": session.get("how_answer", "")},
                            session
                        )

                        self._log_interaction(
                            conn, session_id, "confirm",
                            user_message, response,
                            detected_pattern="modification_request",
                            result="retry",
                            step_attempt=step_attempt
                        )

                        return {
                            "success": True,
                            "message": response,
                            "session_id": session_id,
                            "step": "confirm",
                            "pattern": "modification_request"
                        }

                # =====================================================
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å°ãã®å¯¾è©±ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®å®‰å…¨ãƒ‘ãƒƒãƒï¼‰
                # =====================================================
                # ã“ã“ã«åˆ°é”ã™ã‚‹ã‚±ãƒ¼ã‚¹:
                # - çŸ­æ–‡ã ã£ãŸï¼ˆLLMè§£æã‚¹ã‚­ãƒƒãƒ—ï¼‰
                # - LLMè§£æãŒå¤±æ•—ã—ãŸï¼ˆNoneè¿”å´ï¼‰
                # - LLMè§£æã¯æˆåŠŸã—ãŸãŒæœ‰åŠ¹ãªä¿®æ­£ãŒæŠ½å‡ºã§ããªã‹ã£ãŸ
                #
                # é‡è¦: åŒã˜è¦ç´„ã‚’å†è¡¨ç¤ºã›ãšã€ç›®æ¨™ã®è³ªã‚’ç¢ºèªã™ã‚‹å¯¾è©±ã¸
                # =====================================================
                print(f"   ğŸ’¡ å°ãã®å¯¾è©±ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰")
                response = self._generate_quality_check_response(
                    session, user_message, "clarification_needed"
                )

                self._log_interaction(
                    conn, session_id, "confirm",
                    user_message, response,
                    detected_pattern="clarification_fallback",
                    result="quality_check",
                    step_attempt=step_attempt
                )

                return {
                    "success": True,
                    "message": response,
                    "session_id": session_id,
                    "step": "confirm",
                    "pattern": "clarification_fallback"
                }

        # =====================================================
        # v10.31.5: ä¸æº€æ¤œå‡ºï¼ˆã€Œç­”ãˆãŸã˜ã‚ƒã‚“ã€ç­‰ï¼‰
        # =====================================================
        if self._detect_frustration(user_message):
            print(f"   ğŸ˜¤ ä¸æº€ã‚’æ¤œå‡º: {user_message[:30]}...")
            # ä»Šã¾ã§ã®å›ç­”ã‚’è¦ç´„ã—ã¦ç¢ºèª
            extracted = {
                "why": session.get("why_answer", ""),
                "what": session.get("what_answer", ""),
                "how": session.get("how_answer", "")
            }
            response = f"""ğŸ™ ã”ã‚ã‚“ãªã•ã„ã‚¦ãƒ«ï¼ã¡ã‚ƒã‚“ã¨èã‘ã¦ãªã‹ã£ãŸã‚¦ãƒ«...

{self.user_name}ã•ã‚“ãŒæ•™ãˆã¦ãã‚ŒãŸå†…å®¹ã‚’ã‚‚ã†ä¸€åº¦æ•´ç†ã•ã›ã¦ã‚¦ãƒ«ï¼š

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ ã€WHYã€‘{extracted['why'][:100] if extracted['why'] else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}
ğŸ¯ ã€WHATã€‘{extracted['what'][:100] if extracted['what'] else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}
ğŸ’ª ã€HOWã€‘{extracted['how'][:100] if extracted['how'] else 'ï¼ˆã¾ã èã‘ã¦ã„ãªã„ã‚¦ãƒ«ï¼‰'}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã•ã£ãã®å†…å®¹ã§è¶³ã‚Šãªã„éƒ¨åˆ†ãŒã‚ã‚Œã°ã€ã‚‚ã†ä¸€åº¦æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ã€‚
ã“ã®ç†è§£ã§åˆã£ã¦ãŸã‚‰ã€ŒOKã€ã¨è¨€ã£ã¦ã‚¦ãƒ«ğŸºâœ¨"""

            self._log_interaction(
                conn, session_id, current_step,
                user_message, response,
                detected_pattern="frustration_detected",
                result="retry",
                step_attempt=step_attempt
            )
            return {
                "success": True,
                "message": response,
                "session_id": session_id,
                "step": current_step,
                "pattern": "frustration_detected"
            }

        # =====================================================
        # v10.31.5: é•·æ–‡ã®å ´åˆã¯LLMã§è§£æã—ã¦WHY/WHAT/HOWã‚’æŠ½å‡º
        # =====================================================
        if len(user_message) >= LONG_RESPONSE_THRESHOLD:
            print(f"   ğŸ“ é•·æ–‡ã‚’æ¤œå‡ºï¼ˆ{len(user_message)}æ–‡å­—ï¼‰- LLMè§£æã‚’å®Ÿè¡Œ")
            extracted = self._analyze_long_response_with_llm(user_message, session)

            if extracted:
                # æŠ½å‡ºã—ãŸå†…å®¹ã‚’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ä¿å­˜
                updates = {}
                if extracted.get("why") and not session.get("why_answer"):
                    updates["why_answer"] = extracted["why"]
                    session["why_answer"] = extracted["why"]
                if extracted.get("what") and not session.get("what_answer"):
                    updates["what_answer"] = extracted["what"]
                    session["what_answer"] = extracted["what"]
                if extracted.get("how") and not session.get("how_answer"):
                    updates["how_answer"] = extracted["how"]
                    session["how_answer"] = extracted["how"]

                if updates:
                    # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
                    self._update_session(conn, session_id, **updates)

                # ã™ã¹ã¦æƒã£ãŸã‹ç¢ºèª
                has_why = bool(session.get("why_answer"))
                has_what = bool(session.get("what_answer"))
                has_how = bool(session.get("how_answer"))

                if has_why and has_what and has_how:
                    # ã™ã¹ã¦æƒã£ãŸã‚‰ç¢ºèªç”»é¢ã¸
                    response = self._generate_understanding_response(extracted, session)
                    # v10.31.5: current_stepã‚’'confirm'ã«æ›´æ–°
                    self._update_session(conn, session_id, current_step="confirm")

                    self._log_interaction(
                        conn, session_id, "llm_analysis",
                        user_message, response,
                        detected_pattern="llm_extracted_all",
                        result="retry",  # DB constraint: accepted, retry, abandoned
                        step_attempt=step_attempt
                    )
                    return {
                        "success": True,
                        "message": response,
                        "session_id": session_id,
                        "step": "confirm",
                        "pattern": "llm_extracted_all"
                    }
                else:
                    # è¶³ã‚Šãªã„éƒ¨åˆ†ãŒã‚ã‚‹å ´åˆã¯ã€ç†è§£ã‚’ç¤ºã—ã¤ã¤è¶³ã‚Šãªã„éƒ¨åˆ†ã‚’èã
                    response = self._generate_understanding_response(extracted, session)

                    # æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’æ±ºå®š
                    if not has_why:
                        next_step = "why"
                    elif not has_what:
                        next_step = "what"
                    else:
                        next_step = "how"

                    self._update_session(conn, session_id, current_step=next_step)

                    self._log_interaction(
                        conn, session_id, "llm_analysis",
                        user_message, response,
                        detected_pattern="llm_extracted_partial",
                        result="retry",  # DB constraint: accepted, retry, abandoned
                        step_attempt=step_attempt
                    )
                    return {
                        "success": True,
                        "message": response,
                        "session_id": session_id,
                        "step": next_step,
                        "pattern": "llm_extracted_partial"
                    }

        # v1.7: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’æ§‹ç¯‰
        context = {
            "retry_count": step_attempt - 1,  # 0-indexed
            "why_answer": session.get("why_answer"),
            "what_answer": session.get("what_answer"),
            "session_id": session_id,
        }

        # ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼ˆv1.7: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä»˜ãï¼‰
        pattern, evaluation = self._detect_pattern(user_message, current_step, context)
        print(f"   Detected pattern: {pattern}, evaluation: {evaluation}")

        # ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ˜ãƒ«ã‚¹æ‡¸å¿µã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†
        if pattern == "ng_mental_health":
            response = TEMPLATES["ng_mental_health"].format(user_name=self.user_name)
            self._log_interaction(
                conn, session_id, current_step,
                user_message, response,
                detected_pattern=pattern,
                evaluation_result=evaluation,
                feedback_given=True,
                result="abandoned",
                step_attempt=step_attempt
            )
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä¸­æ–­
            self._update_session(conn, session_id, current_step=current_step, status="abandoned")
            return {
                "success": True,
                "message": response,
                "session_id": session_id,
                "step": current_step,
                "pattern": pattern
            }

        # NGãƒ‘ã‚¿ãƒ¼ãƒ³ã®å ´åˆ
        if pattern != "ok":
            # v1.7: help_question/help_confused ã¯ãƒªãƒˆãƒ©ã‚¤ä¸Šé™ã«å«ã‚ãªã„
            is_help_request = pattern.startswith("help_question_") or pattern.startswith("help_confused_")

            # ãƒªãƒˆãƒ©ã‚¤ä¸Šé™ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ˜ãƒ«ãƒ—è¦æ±‚ã¯é™¤ãï¼‰
            if not is_help_request and step_attempt >= MAX_RETRY_COUNT:
                # ä¸Šé™ã«é”ã—ãŸã‚‰å—ã‘å…¥ã‚Œã¦æ¬¡ã¸é€²ã‚€
                return self._accept_and_proceed(conn, session, user_message, current_step,
                                               pattern, evaluation, step_attempt)

            # ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¿”ã™ï¼ˆv1.7: step, step_attemptè¿½åŠ ï¼‰
            response = self._get_feedback_response(
                pattern, user_message, session,
                step=current_step,
                step_attempt=step_attempt
            )
            self._log_interaction(
                conn, session_id, current_step,
                user_message, response,
                detected_pattern=pattern,
                evaluation_result=evaluation,
                feedback_given=True,
                result="retry",
                step_attempt=step_attempt
            )

            # Phase 2.5 + B Memoryçµ±åˆ: ãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰å­¦ç¿’
            specificity_score = evaluation.get("specificity_score", 0.0) if evaluation else 0.0
            self._learn_from_interaction(
                conn, session, current_step, pattern,
                was_accepted=False,
                retry_count=step_attempt,
                specificity_score=specificity_score
            )

            return {
                "success": True,
                "message": response,
                "session_id": session_id,
                "step": current_step,
                "pattern": pattern
            }

        # OK: æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸é€²ã‚€
        return self._accept_and_proceed(conn, session, user_message, current_step,
                                       pattern, evaluation, step_attempt)

    def _accept_and_proceed(self, conn, session: Dict[str, Any], user_message: str,
                           current_step: str, pattern: str, evaluation: dict,
                           step_attempt: int) -> Dict[str, Any]:
        """
        å›ç­”ã‚’å—ã‘å…¥ã‚Œã¦æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸é€²ã‚€

        v10.40.3: ãƒ•ã‚§ãƒ¼ã‚ºè‡ªå‹•åˆ¤å®š
        ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ã‹ã‚‰è¤‡æ•°ãƒ•ã‚§ãƒ¼ã‚ºã®æƒ…å ±ã‚’æ¤œå‡ºã—ã€
        æ—¢ã«å……è¶³ã—ã¦ã„ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã¯ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã€‚
        """
        session_id = session["id"]

        # v10.40.3: ãƒ•ã‚§ãƒ¼ã‚ºè‡ªå‹•åˆ¤å®š
        fulfilled = _infer_fulfilled_phases(user_message)
        print(f"   ğŸ§  ãƒ•ã‚§ãƒ¼ã‚ºåˆ¤å®š: {fulfilled}")

        # å›ç­”ã‚’ä¿å­˜ï¼ˆç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ— + è¿½åŠ ã§æ¤œå‡ºã•ã‚ŒãŸãƒ•ã‚§ãƒ¼ã‚ºï¼‰
        if current_step == "why":
            # WHYå›ç­”ã‚’ä¿å­˜
            session["why_answer"] = user_message

            # v10.40.3: WHAT/HOWæƒ…å ±ã‚‚å«ã¾ã‚Œã¦ã„ã‚Œã°æŠ½å‡º
            updates = {"why_answer": user_message}
            if fulfilled.get("what"):
                # WHATãƒ¬ãƒ™ãƒ«ã®æƒ…å ±ï¼ˆãƒ†ãƒ¼ãƒãƒ»ç›®æ¨™ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹
                print(f"   ğŸ¯ WHATæƒ…å ±ã‚‚æ¤œå‡º: ãƒ†ãƒ¼ãƒãƒ»é ˜åŸŸã‚’å«ã‚€")
                # ãƒ†ãƒ¼ãƒã‚’æŠ½å‡ºã—ã¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ä¿å­˜ï¼ˆæ¬¡ã®è³ªå•ã§ä½¿ã†ï¼‰
                session["detected_themes"] = user_message

            # æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’æ±ºå®š
            next_step = _get_next_unfulfilled_step(fulfilled, current_step, session)

            if next_step == "what" and fulfilled.get("what"):
                # ãƒ†ãƒ¼ãƒã¯åˆ†ã‹ã£ã¦ã„ã‚‹ãŒå…·ä½“çš„ãªæ•°å€¤ãŒãªã„å ´åˆ
                # ã‚¹ãƒãƒ¼ãƒˆè³ªå•ã‚’ä½¿ç”¨
                themes = self._extract_themes_from_message(user_message)
                if themes:
                    response = TEMPLATES["smart_what_with_themes"].format(
                        user_name=self.user_name,
                        themes=themes,
                        theme_example=themes.split("ã€")[0] if "ã€" in themes else themes
                    )
                else:
                    feedback = f"ã€Œ{user_message[:30]}...ã€ã¨ã„ã†æƒ³ã„ã‚’æŒã£ã¦ã„ã‚‹ã‚“ã ã­ï¼"
                    response = TEMPLATES["why_to_what"].format(
                        user_name=self.user_name,
                        feedback=feedback
                    )
            elif next_step == "how":
                # WHATã‚‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¦HOWã¸
                feedback = f"ã€Œ{user_message[:30]}...ã€ã‚’ç›®æŒ‡ã™ã‚“ã ã­ï¼"
                response = TEMPLATES["what_to_how"].format(
                    user_name=self.user_name,
                    feedback=feedback
                )
            elif next_step == "confirm":
                # å…¨ã¦æƒã£ãŸï¼ˆç¨€ãªã‚±ãƒ¼ã‚¹ï¼‰
                response = self._generate_understanding_response(
                    {"why": user_message, "what": "", "how": ""},
                    session
                )
            else:
                feedback = f"ã€Œ{user_message[:30]}...ã€ã¨ã„ã†æƒ³ã„ã‚’æŒã£ã¦ã„ã‚‹ã‚“ã ã­ï¼"
                response = TEMPLATES["why_to_what"].format(
                    user_name=self.user_name,
                    feedback=feedback
                )

            self._update_session(conn, session_id, current_step=next_step, **updates)

        elif current_step == "what":
            session["what_answer"] = user_message
            updates = {"what_answer": user_message}

            # æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’æ±ºå®š
            next_step = _get_next_unfulfilled_step(fulfilled, current_step, session)

            if next_step == "how" and fulfilled.get("how"):
                # HOWæƒ…å ±ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯confirmã¸
                next_step = "confirm"
                response = self._generate_understanding_response(
                    {"why": session.get("why_answer", ""),
                     "what": user_message,
                     "how": ""},
                    session
                )
            else:
                feedback = f"ã€Œ{user_message[:30]}...ã€ã‚’ç›®æŒ‡ã™ã‚“ã ã­ï¼"
                response = TEMPLATES["what_to_how"].format(
                    user_name=self.user_name,
                    feedback=feedback
                )

            self._update_session(conn, session_id, current_step=next_step, **updates)

        elif current_step == "how":
            # ç›®æ¨™ç™»éŒ²
            session["why_answer"] = session.get("why_answer", "")
            session["what_answer"] = session.get("what_answer", "")
            session["how_answer"] = user_message

            goal_id = self._register_goal(conn, session)
            self._update_session(
                conn, session_id,
                current_step="complete",
                how_answer=user_message,
                status="completed",
                goal_id=goal_id
            )
            next_step = "complete"
            response = TEMPLATES["complete"].format(
                user_name=self.user_name,
                why_answer=session.get("why_answer", ""),
                what_answer=session.get("what_answer", ""),
                how_answer=user_message
            )

            # Phase 2.5 + B Memoryçµ±åˆ: ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã®å­¦ç¿’
            self._update_session_stats_on_complete(conn, session)
        else:
            # intro ã‚¹ãƒ†ãƒƒãƒ—ã¯ã“ã“ã«ã¯æ¥ãªã„ï¼ˆstart_or_continue ã§å‡¦ç†ï¼‰
            return {
                "success": False,
                "message": "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚¦ãƒ«..."
            }

        # ãƒ­ã‚°ã‚’è¨˜éŒ²
        self._log_interaction(
            conn, session_id, current_step,
            user_message, response,
            detected_pattern=pattern,
            evaluation_result=evaluation,
            feedback_given=False,
            result="accepted",
            step_attempt=step_attempt
        )

        # Phase 2.5 + B Memoryçµ±åˆ: OKãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰å­¦ç¿’
        specificity_score = evaluation.get("specificity_score", 0.0) if evaluation else 0.0
        self._learn_from_interaction(
            conn, session, current_step, pattern,
            was_accepted=True,
            retry_count=step_attempt,
            specificity_score=specificity_score
        )

        return {
            "success": True,
            "message": response,
            "session_id": session_id,
            "step": next_step,
            "pattern": pattern
        }

    def _get_feedback_response(self, pattern: str, user_message: str,
                               session: Dict[str, Any],
                               step: str = None,
                               step_attempt: int = 1) -> str:
        """
        ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¿œã˜ãŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¿”ã™ï¼ˆv1.7æ‹¡å¼µï¼‰

        Args:
            pattern: æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³
            user_message: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            session: ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±
            step: ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—
            step_attempt: è©¦è¡Œå›æ•°
        """
        # Noneãƒã‚§ãƒƒã‚¯
        why_answer = session.get("why_answer") or ""
        what_answer = session.get("what_answer") or ""
        user_answer = user_message[:50] if user_message else ""

        # v1.7: WHY/WHATå›ç­”ã®ã‚µãƒãƒªãƒ¼ï¼ˆhelp_confusedç”¨ï¼‰
        why_summary = why_answer[:30] + "..." if len(why_answer) > 30 else why_answer
        what_summary = what_answer[:30] + "..." if len(what_answer) > 30 else what_answer

        # v1.7: ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ã®ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ï¼ˆtoo_shortç”¨ï¼‰
        step_guidance = self._get_step_guidance(step)
        step_hint = self._get_step_hint(step)

        # =====================================================
        # v1.7: æ–°ã—ã„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å‡¦ç†
        # =====================================================

        # è³ªå•å¯¾å¿œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
        if pattern == "help_question_why" and "help_question_why" in TEMPLATES:
            return TEMPLATES["help_question_why"].format(user_name=self.user_name)

        if pattern == "help_question_what" and "help_question_what" in TEMPLATES:
            return TEMPLATES["help_question_what"].format(user_name=self.user_name)

        if pattern == "help_question_how" and "help_question_how" in TEMPLATES:
            return TEMPLATES["help_question_how"].format(user_name=self.user_name)

        # å›°æƒ‘å¯¾å¿œãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
        if pattern == "help_confused_why" and "help_confused_why" in TEMPLATES:
            return TEMPLATES["help_confused_why"].format(user_name=self.user_name)

        if pattern == "help_confused_what" and "help_confused_what" in TEMPLATES:
            return TEMPLATES["help_confused_what"].format(
                user_name=self.user_name,
                why_summary=why_summary
            )

        if pattern == "help_confused_how" and "help_confused_how" in TEMPLATES:
            return TEMPLATES["help_confused_how"].format(
                user_name=self.user_name,
                what_summary=what_summary
            )

        # æ¥µç«¯ã«çŸ­ã„å›ç­”
        if pattern == "too_short" and "too_short" in TEMPLATES:
            return TEMPLATES["too_short"].format(
                user_name=self.user_name,
                user_answer=user_answer,
                step_guidance=step_guidance
            )

        # v1.7: ãƒªãƒˆãƒ©ã‚¤å›æ•°ã«å¿œã˜ãŸãƒˆãƒ¼ãƒ³å¤‰æ›´
        if step_attempt >= 3 and "retry_accepting" in TEMPLATES:
            # 3å›ç›®ä»¥é™ã¯å—ã‘å…¥ã‚Œæº–å‚™
            return TEMPLATES["retry_accepting"].format(
                user_name=self.user_name,
                user_answer=user_answer
            )

        if step_attempt == 2 and "retry_gentle" in TEMPLATES:
            # 2å›ç›®ã¯å„ªã—ã„ãƒˆãƒ¼ãƒ³
            return TEMPLATES["retry_gentle"].format(
                user_name=self.user_name,
                step_hint=step_hint
            )

        # =====================================================
        # æ—¢å­˜ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å‡¦ç†
        # =====================================================
        if pattern in TEMPLATES:
            response = TEMPLATES[pattern].format(
                user_name=self.user_name,
                user_answer=user_answer,
                what_answer=what_answer[:50]
            )
            # Phase 2.5 + B Memoryçµ±åˆ: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚º
            return self._personalize_feedback(response, pattern, step, step_attempt)

        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
        response = TEMPLATES["ng_abstract"].format(
            user_name=self.user_name,
            user_answer=user_answer
        )
        # Phase 2.5 + B Memoryçµ±åˆ: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚º
        return self._personalize_feedback(response, pattern, step, step_attempt)

    def _get_step_guidance(self, step: str) -> str:
        """ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ã®ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã‚’è¿”ã™ï¼ˆv1.7æ–°è¦ï¼‰"""
        guidance = {
            "why": "ä»•äº‹ã‚’é€šã˜ã¦ã€ã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ã‹æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº",
            "what": "å…·ä½“çš„ã«ä½•ã‚’é”æˆã—ãŸã„ã‹ã€æ•°å­—ã‚„æœŸé™ã‚’å…¥ã‚Œã¦æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº",
            "how": "æ¯æ—¥ãƒ»æ¯é€±ã©ã‚“ãªè¡Œå‹•ã‚’ã™ã‚‹ã‹æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº",
        }
        return guidance.get(step, "ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº")

    def _get_step_hint(self, step: str) -> str:
        """ã‚¹ãƒ†ãƒƒãƒ—åˆ¥ã®ãƒ’ãƒ³ãƒˆã‚’è¿”ã™ï¼ˆv1.7æ–°è¦ï¼‰"""
        hints = {
            "why": """ä¾‹ãˆã°...
â€¢ ã€Œãƒãƒ¼ãƒ ã«è²¢çŒ®ã§ãã‚‹äººã«ãªã‚ŠãŸã„ã€
â€¢ ã€ŒãŠå®¢æ§˜ã«å–œã‚“ã§ã‚‚ã‚‰ãˆã‚‹ä»•äº‹ãŒã—ãŸã„ã€
â€¢ ã€Œæˆé•·ã—ã¦æ–°ã—ã„ã“ã¨ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãŸã„ã€""",
            "what": """ä¾‹ãˆã°...
â€¢ ã€Œä»Šæœˆã®å£²ä¸Šã‚’ã€‡ã€‡å††ã«ã—ãŸã„ã€
â€¢ ã€Œæ–°è¦é¡§å®¢ã‚’ã€‡ä»¶ç²å¾—ã—ãŸã„ã€
â€¢ ã€Œã€‡æœˆã¾ã§ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å®Œäº†ã•ã›ãŸã„ã€""",
            "how": """ä¾‹ãˆã°...
â€¢ ã€Œæ¯æ—¥ã€‡ã€‡ã‚’ã™ã‚‹ã€
â€¢ ã€Œé€±ã«ã€‡å›â–³â–³ã‚’ã™ã‚‹ã€
â€¢ ã€Œæ¯æœ/æ¯æ™©ã€‡ã€‡ã‚’ç¶šã‘ã‚‹ã€""",
        }
        return hints.get(step, "å…·ä½“çš„ã«æ•™ãˆã¦ã»ã—ã„ã‚¦ãƒ«ğŸº")

    def _get_current_question(self, session: Dict[str, Any]) -> Dict[str, Any]:
        """ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã®è³ªå•ã‚’è¿”ã™"""
        current_step = session["current_step"]

        if current_step == "why":
            return {
                "success": True,
                "message": "â“ ã€WHYã€‘ã“ã®å…ˆã€ä»•äº‹ã‚’é€šã˜ã¦ã©ã‚“ãªè‡ªåˆ†ã«ãªã‚ŠãŸã„ã§ã™ã‹ï¼Ÿ\n\n" +
                          f"{self.user_name}ã•ã‚“ã®æƒ³ã„ã‚’æ•™ãˆã¦ã‚¦ãƒ«ğŸºâœ¨",
                "session_id": session["id"],
                "step": current_step
            }
        elif current_step == "what":
            return {
                "success": True,
                "message": "â“ ã€WHATã€‘å…·ä½“çš„ã«ã©ã‚“ãªæˆæœã‚’å‡ºã—ãŸã„ã§ã™ã‹ï¼Ÿ\n\n" +
                          "æ•°å­—ã‚„æœŸé™ã‚’å…¥ã‚Œã¦ãã‚Œã‚‹ã¨å¬‰ã—ã„ã‚¦ãƒ«ğŸº",
                "session_id": session["id"],
                "step": current_step
            }
        elif current_step == "how":
            return {
                "success": True,
                "message": "â“ ã€HOWã€‘ç›®æ¨™é”æˆã®ãŸã‚ã«ã€ã©ã‚“ãªè¡Œå‹•ã‚’ã—ã¾ã™ã‹ï¼Ÿ\n\n" +
                          "ã€Œæ¯æ—¥ã€‡ã€‡ã‚’ã™ã‚‹ã€ãªã©å…·ä½“çš„ã«æ•™ãˆã¦ã‚¦ãƒ«ğŸº",
                "session_id": session["id"],
                "step": current_step
            }
        else:
            return {
                "success": True,
                "message": "ç›®æ¨™è¨­å®šãŒå®Œäº†ã—ã¦ã„ã‚‹ã‚¦ãƒ«ï¼\næ–°ã—ã„ç›®æ¨™ã‚’è¨­å®šã™ã‚‹ãªã‚‰ã€Œç›®æ¨™ã‚’è¨­å®šã—ãŸã„ã€ã¨è¨€ã£ã¦ã‚¦ãƒ«ğŸº",
                "session_id": session["id"],
                "step": current_step
            }

    # =====================================================
    # Phase 2.5 + B Memoryçµ±åˆãƒ¡ã‚½ãƒƒãƒ‰
    # =====================================================

    def _load_memory_context(self, conn) -> None:
        """Memory Frameworkã‹ã‚‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰"""
        if not self.user_id or not self.org_id:
            return

        try:
            # GoalSettingContextEnricherã‚’lazy load
            # v10.31.4: ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤‰æ›´ï¼ˆgoogleapiclientè­¦å‘Šä¿®æ­£ï¼‰
            from .memory.goal_integration import GoalSettingContextEnricher

            enricher = GoalSettingContextEnricher(conn, self.org_id)
            # åŒæœŸç‰ˆã¨ã—ã¦å‘¼ã³å‡ºã—ï¼ˆasyncioãŒãªã„ç’°å¢ƒå‘ã‘ï¼‰
            self.enriched_context = self._get_sync_context(enricher)

            # ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æå™¨ã‚’åˆæœŸåŒ–
            self.pattern_analyzer = GoalSettingUserPatternAnalyzer(conn, self.org_id)

        except ImportError:
            # Memory FrameworkãŒåˆ©ç”¨ä¸å¯ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            print("âš ï¸ Memory Framework not available, skipping context enrichment")
        except Exception as e:
            print(f"âš ï¸ Memoryã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")

    def _get_sync_context(self, enricher) -> Dict[str, Any]:
        """åŒæœŸçš„ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ï¼ˆasyncioãªã—ç’°å¢ƒå‘ã‘ï¼‰"""
        try:
            # goal_setting_user_patternsã‹ã‚‰ç›´æ¥å–å¾—
            context = {
                "conversation_summary": {},
                "user_preferences": {},
                "goal_patterns": enricher._get_goal_pattern_context(self.user_id),
                "recommendations": {}
            }
            context["recommendations"] = enricher._generate_recommendations(context)
            return context
        except Exception as e:
            print(f"âš ï¸ Sync context error: {e}")
            return enricher._empty_context()

    def _personalize_feedback(
        self,
        base_response: str,
        pattern: str,
        step: str,
        step_attempt: int
    ) -> str:
        """ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚º"""
        if not self.enriched_context:
            return base_response

        context = self.enriched_context
        goal_patterns = context.get("goal_patterns", {})
        recommendations = context.get("recommendations", {})

        # éå»ã®æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‚ç…§
        if goal_patterns.get("completion_rate", 0) >= 70:
            # å®Œäº†ç‡ãŒé«˜ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯åŠ±ã¾ã—ã‚’å¼·åŒ–
            if step_attempt == 1:
                base_response = base_response.replace(
                    "ğŸº",
                    "ğŸºâœ¨ï¼ˆ{name}ã•ã‚“ã€ã„ã¤ã‚‚å…·ä½“çš„ã«ç­”ãˆã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã‚¦ãƒ«ï¼ï¼‰".format(
                        name=self.user_name
                    ),
                    1  # æœ€åˆã®1ã¤ã ã‘ç½®æ›
                )

        # æ„Ÿæƒ…å‚¾å‘ã‚’è€ƒæ…®
        prefs = context.get("user_preferences", {})
        emotion_trend = prefs.get("emotion_trend", {})
        if emotion_trend:
            trend_direction = emotion_trend.get("trend_direction")
            if trend_direction == "declining":
                # æ„Ÿæƒ…ãŒä¸‹é™å‚¾å‘ã®å ´åˆã¯åŠ±ã¾ã—ã‚’å¼·åŒ–
                base_response = base_response.replace("ğŸº", "ğŸºğŸ’™")

        # ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¨ãƒªã‚¢ã‚’ãƒ’ãƒ³ãƒˆã¨ã—ã¦è¿½åŠ ï¼ˆãƒªãƒˆãƒ©ã‚¤æ™‚ï¼‰
        focus_areas = recommendations.get("focus_areas", [])
        if step_attempt >= 2 and focus_areas:
            hint = focus_areas[0]
            if "å…·ä½“çš„" in hint or "æ•°å€¤" in hint:
                base_response += f"\n\nğŸ’¡ ãƒ’ãƒ³ãƒˆ: {hint}"

        return base_response

    def _learn_from_interaction(
        self,
        conn,
        session: Dict[str, Any],
        step: str,
        pattern: str,
        was_accepted: bool,
        retry_count: int,
        specificity_score: float = 0.0
    ) -> None:
        """ç›®æ¨™è¨­å®šå¯¾è©±ã‹ã‚‰å­¦ç¿’ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›´æ–°"""
        if not self.pattern_analyzer:
            return

        try:
            self.pattern_analyzer.update_user_pattern(
                user_id=self.user_id,
                session_id=session.get("id", ""),
                step=step,
                pattern=pattern,
                was_accepted=was_accepted,
                retry_count=retry_count,
                specificity_score=specificity_score
            )
        except Exception as e:
            print(f"âš ï¸ å­¦ç¿’ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")

    def _update_session_stats_on_complete(self, conn, session: Dict[str, Any]) -> None:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«çµ±è¨ˆã‚’æ›´æ–°"""
        if not self.pattern_analyzer:
            return

        try:
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³å†…ã®ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’è¨ˆç®—
            total_retry = self._get_total_retry_count(conn, session["id"])

            self.pattern_analyzer.update_session_stats(
                user_id=self.user_id,
                completed=True,
                total_retry_count=total_retry
            )

            # B2 ãƒ¦ãƒ¼ã‚¶ãƒ¼å—œå¥½ã«ç›®æ¨™è¨­å®šä½¿ç”¨ã‚’è¨˜éŒ²
            self._update_preference_on_complete(conn, session)

        except Exception as e:
            print(f"âš ï¸ ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆæ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")

    def _get_total_retry_count(self, conn, session_id: str) -> int:
        """
        ã‚»ãƒƒã‚·ãƒ§ãƒ³å†…ã®ç·ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’å–å¾—ï¼ˆv1.8: brain_dialogue_logsä½¿ç”¨ï¼‰

        chatwork_account_idã¨room_idã§24æ™‚é–“ä»¥å†…ã®ãƒªãƒˆãƒ©ã‚¤ã‚’æ¤œç´¢ã€‚
        """
        try:
            result = conn.execute(
                text("""
                    SELECT COUNT(*) FROM brain_dialogue_logs
                    WHERE chatwork_account_id = :account_id
                      AND room_id = :room_id
                      AND organization_id = :org_id
                      AND state_type = 'goal_setting'
                      AND result = 'retry'
                      AND created_at > CURRENT_TIMESTAMP - INTERVAL '24 hours'
                """),
                {
                    "account_id": self.account_id,
                    "room_id": self.room_id,
                    "org_id": self.org_id
                }
            ).fetchone()
            return result[0] if result else 0
        except Exception:
            return 0

    def _update_preference_on_complete(self, conn, session: Dict[str, Any]) -> None:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«B2å—œå¥½ã‚’æ›´æ–°"""
        try:
            # v10.31.4: ç›¸å¯¾ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤‰æ›´ï¼ˆgoogleapiclientè­¦å‘Šä¿®æ­£ï¼‰
            from .memory.user_preference import UserPreference
            from uuid import UUID

            pref_service = UserPreference(conn, UUID(self.org_id))

            # ç›®æ¨™è¨­å®šæ©Ÿèƒ½ã®ä½¿ç”¨ã‚’è¨˜éŒ²
            import asyncio
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)

            # åŒæœŸçš„ã«ä¿å­˜ï¼ˆCloud Functionsç’°å¢ƒå‘ã‘ï¼‰
            conn.execute(
                text("""
                    INSERT INTO user_preferences (
                        organization_id, user_id, preference_type, preference_key,
                        preference_value, learned_from, confidence
                    ) VALUES (
                        :org_id, :user_id, 'feature_usage', 'goal_setting',
                        :pref_value, 'auto', 0.5
                    )
                    ON CONFLICT (organization_id, user_id, preference_type, preference_key)
                    DO UPDATE SET
                        preference_value = :pref_value,
                        sample_count = user_preferences.sample_count + 1,
                        confidence = LEAST(user_preferences.confidence + 0.1, 0.95),
                        updated_at = CURRENT_TIMESTAMP
                """),
                {
                    "org_id": self.org_id,
                    "user_id": self.user_id,
                    "pref_value": json.dumps({
                        "last_completed": datetime.now().isoformat(),
                        "session_id": session.get("id")
                    })
                }
            )
            conn.commit()

        except ImportError:
            pass
        except Exception as e:
            print(f"âš ï¸ å—œå¥½æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")


def has_active_goal_session(pool, room_id: str, account_id: str) -> bool:
    """
    ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™è¨­å®šã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆv1.8: brain_conversation_statesä½¿ç”¨ï¼‰

    chatwork-webhook ã‹ã‚‰å‘¼ã³å‡ºã—ã¦ã€é€šå¸¸ã®AIå¿œç­”ã‚’ãƒã‚¤ãƒ‘ã‚¹ã™ã‚‹ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹ã€‚
    user_id ã¨ã—ã¦ chatwork_account_id ã‚’ç›´æ¥ä½¿ç”¨ã€‚
    """
    with pool.connect() as conn:
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆorg_idã®å–å¾—ã®ã¿ï¼‰
        user_result = conn.execute(
            text("""
                SELECT organization_id FROM users
                WHERE chatwork_account_id = :account_id
                LIMIT 1
            """),
            {"account_id": str(account_id)}
        ).fetchone()

        if not user_result:
            return False

        org_id = str(user_result[0]) if user_result[0] else None

        if not org_id:
            return False

        # brain_conversation_statesã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
        result = conn.execute(
            text("""
                SELECT COUNT(*) FROM brain_conversation_states
                WHERE user_id = :account_id
                  AND organization_id = :org_id
                  AND room_id = :room_id
                  AND state_type = 'goal_setting'
                  AND expires_at > CURRENT_TIMESTAMP
            """),
            {
                "account_id": str(account_id),
                "org_id": org_id,
                "room_id": str(room_id)
            }
        ).fetchone()

        return result and result[0] > 0


def process_goal_setting_message(pool, room_id: str, account_id: str,
                                  message: str) -> Dict[str, Any]:
    """
    ç›®æ¨™è¨­å®šå¯¾è©±ã‚’å‡¦ç†

    ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã‚‹å ´åˆã¯ãã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¶™ç¶šã€
    ãªã‘ã‚Œã°æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã€‚
    """
    dialogue = GoalSettingDialogue(pool, room_id, account_id)
    return dialogue.start_or_continue(message)


# =====================================================
# Phase 2.5 + B Memoryçµ±åˆ: ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æã‚¯ãƒ©ã‚¹
# =====================================================

class GoalSettingUserPatternAnalyzer:
    """
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç›®æ¨™è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æãƒ»è“„ç©

    ç›®æ¨™è¨­å®šå¯¾è©±ã®çµæœã‚’è“„ç©ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‚¾å‘ã‚’åˆ†æã™ã‚‹ã€‚
    ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç”Ÿæˆã«æ´»ç”¨ã€‚

    ä½¿ç”¨ä¾‹:
        analyzer = GoalSettingUserPatternAnalyzer(conn, org_id)
        analyzer.update_user_pattern(user_id, session_id, "why", "ng_abstract", False, 2)
        summary = analyzer.get_user_pattern_summary(user_id)
    """

    def __init__(self, conn, org_id: str):
        """
        åˆæœŸåŒ–

        Args:
            conn: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
            org_id: çµ„ç¹”IDï¼ˆãƒ†ãƒŠãƒ³ãƒˆåˆ†é›¢ç”¨ï¼‰
        """
        self.conn = conn
        self.org_id = str(org_id) if org_id else None

    def update_user_pattern(
        self,
        user_id: str,
        session_id: str,
        step: str,
        pattern: str,
        was_accepted: bool,
        retry_count: int,
        specificity_score: float = 0.0
    ) -> None:
        """
        ç›®æ¨™è¨­å®šå¯¾è©±ã®çµæœã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åæ˜ 

        Args:
            user_id: ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            session_id: ã‚»ãƒƒã‚·ãƒ§ãƒ³ID
            step: ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆwhy/what/howï¼‰
            pattern: æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³
            was_accepted: å›ç­”ãŒå—ã‘å…¥ã‚Œã‚‰ã‚ŒãŸã‹
            retry_count: ã“ã®ã‚¹ãƒ†ãƒƒãƒ—ã§ã®ãƒªãƒˆãƒ©ã‚¤å›æ•°
            specificity_score: å…·ä½“æ€§ã‚¹ã‚³ã‚¢ï¼ˆ0-1ï¼‰
        """
        if not self.org_id or not user_id:
            return

        try:
            # æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
            existing = self.conn.execute(
                text("""
                    SELECT id, pattern_history, total_sessions,
                           why_pattern_tendency, what_pattern_tendency, how_pattern_tendency,
                           avg_specificity_score
                    FROM goal_setting_user_patterns
                    WHERE organization_id = :org_id AND user_id = :user_id
                """),
                {"org_id": self.org_id, "user_id": str(user_id)}
            ).fetchone()

            if existing:
                # æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°
                self._update_existing_pattern(
                    existing, step, pattern, was_accepted, retry_count, specificity_score
                )
            else:
                # æ–°è¦ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆ
                self._create_new_pattern(
                    user_id, step, pattern, was_accepted, retry_count, specificity_score
                )

            self.conn.commit()

        except Exception as e:
            print(f"âš ï¸ ãƒ‘ã‚¿ãƒ¼ãƒ³æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")

    def _update_existing_pattern(
        self,
        existing,
        step: str,
        pattern: str,
        was_accepted: bool,
        retry_count: int,
        specificity_score: float
    ) -> None:
        """æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°"""
        record_id = existing[0]
        pattern_history = existing[1] or {}
        total_sessions = existing[2] or 0
        why_tendency = existing[3] or {}
        what_tendency = existing[4] or {}
        how_tendency = existing[5] or {}
        avg_score = float(existing[6] or 0)

        # ãƒ‘ã‚¿ãƒ¼ãƒ³å±¥æ­´ã‚’æ›´æ–°
        pattern_history[pattern] = pattern_history.get(pattern, 0) + 1

        # ã‚¹ãƒ†ãƒƒãƒ—åˆ¥å‚¾å‘ã‚’æ›´æ–°
        step_tendencies = {
            "why": why_tendency,
            "what": what_tendency,
            "how": how_tendency
        }
        if step in step_tendencies:
            step_tendencies[step][pattern] = step_tendencies[step].get(pattern, 0) + 1

        # æœ€é »å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨ˆç®—
        dominant = max(pattern_history, key=pattern_history.get) if pattern_history else None

        # å¹³å‡å…·ä½“æ€§ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ï¼ˆç§»å‹•å¹³å‡ï¼‰
        new_avg_score = (avg_score * 0.8) + (specificity_score * 0.2)

        self.conn.execute(
            text("""
                UPDATE goal_setting_user_patterns
                SET pattern_history = :pattern_history,
                    dominant_pattern = :dominant,
                    why_pattern_tendency = :why_tendency,
                    what_pattern_tendency = :what_tendency,
                    how_pattern_tendency = :how_tendency,
                    avg_specificity_score = :avg_score,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = :id
            """),
            {
                "id": str(record_id),
                "pattern_history": json.dumps(pattern_history),
                "dominant": dominant,
                "why_tendency": json.dumps(step_tendencies["why"]),
                "what_tendency": json.dumps(step_tendencies["what"]),
                "how_tendency": json.dumps(step_tendencies["how"]),
                "avg_score": new_avg_score
            }
        )

    def _create_new_pattern(
        self,
        user_id: str,
        step: str,
        pattern: str,
        was_accepted: bool,
        retry_count: int,
        specificity_score: float
    ) -> None:
        """æ–°è¦ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆ"""
        pattern_history = {pattern: 1}
        step_tendencies = {"why": {}, "what": {}, "how": {}}
        if step in step_tendencies:
            step_tendencies[step] = {pattern: 1}

        self.conn.execute(
            text("""
                INSERT INTO goal_setting_user_patterns (
                    organization_id, user_id, pattern_history, dominant_pattern,
                    why_pattern_tendency, what_pattern_tendency, how_pattern_tendency,
                    total_sessions, avg_specificity_score
                ) VALUES (
                    :org_id, :user_id, :pattern_history, :dominant,
                    :why_tendency, :what_tendency, :how_tendency,
                    1, :avg_score
                )
            """),
            {
                "org_id": self.org_id,
                "user_id": str(user_id),
                "pattern_history": json.dumps(pattern_history),
                "dominant": pattern,
                "why_tendency": json.dumps(step_tendencies["why"]),
                "what_tendency": json.dumps(step_tendencies["what"]),
                "how_tendency": json.dumps(step_tendencies["how"]),
                "avg_score": specificity_score
            }
        )

    def update_session_stats(
        self,
        user_id: str,
        completed: bool,
        total_retry_count: int
    ) -> None:
        """
        ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆã‚’æ›´æ–°

        Args:
            user_id: ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            completed: ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ãŸã‹
            total_retry_count: ã‚»ãƒƒã‚·ãƒ§ãƒ³å…¨ä½“ã®ãƒªãƒˆãƒ©ã‚¤å›æ•°
        """
        if not self.org_id or not user_id:
            return

        try:
            self.conn.execute(
                text("""
                    UPDATE goal_setting_user_patterns
                    SET total_sessions = total_sessions + 1,
                        completed_sessions = completed_sessions + :completed,
                        completion_rate = CASE
                            WHEN total_sessions + 1 > 0
                            THEN ((completed_sessions + :completed)::DECIMAL / (total_sessions + 1)) * 100
                            ELSE 0
                        END,
                        avg_retry_count = CASE
                            WHEN total_sessions + 1 > 0
                            THEN ((avg_retry_count * total_sessions) + :retry_count) / (total_sessions + 1)
                            ELSE :retry_count
                        END,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE organization_id = :org_id AND user_id = :user_id
                """),
                {
                    "org_id": self.org_id,
                    "user_id": str(user_id),
                    "completed": 1 if completed else 0,
                    "retry_count": total_retry_count
                }
            )
            self.conn.commit()
        except Exception as e:
            print(f"âš ï¸ ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆæ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¶šè¡Œï¼‰: {e}")

    def get_user_pattern_summary(self, user_id: str) -> Optional[Dict[str, Any]]:
        """
        ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³å‚¾å‘ã‚µãƒãƒªãƒ¼ã‚’å–å¾—

        Args:
            user_id: ãƒ¦ãƒ¼ã‚¶ãƒ¼ID

        Returns:
            ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒãƒªãƒ¼è¾æ›¸ã€ã¾ãŸã¯None
        """
        if not self.org_id or not user_id:
            return None

        try:
            result = self.conn.execute(
                text("""
                    SELECT
                        dominant_pattern,
                        pattern_history,
                        total_sessions,
                        completed_sessions,
                        avg_retry_count,
                        completion_rate,
                        why_pattern_tendency,
                        what_pattern_tendency,
                        how_pattern_tendency,
                        avg_specificity_score,
                        preferred_feedback_style
                    FROM goal_setting_user_patterns
                    WHERE organization_id = :org_id AND user_id = :user_id
                """),
                {"org_id": self.org_id, "user_id": str(user_id)}
            ).fetchone()

            if not result:
                return None

            return {
                "dominant_pattern": result[0],
                "pattern_history": result[1] or {},
                "total_sessions": result[2] or 0,
                "completed_sessions": result[3] or 0,
                "avg_retry_count": float(result[4] or 0),
                "completion_rate": float(result[5] or 0),
                "why_pattern_tendency": result[6] or {},
                "what_pattern_tendency": result[7] or {},
                "how_pattern_tendency": result[8] or {},
                "avg_specificity_score": float(result[9] or 0),
                "preferred_feedback_style": result[10],
                "recommendations": self._generate_recommendations(result)
            }

        except Exception as e:
            print(f"âš ï¸ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒãƒªãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def _generate_recommendations(self, result) -> Dict[str, Any]:
        """ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æçµæœã‹ã‚‰æ¨å¥¨äº‹é …ã‚’ç”Ÿæˆ"""
        dominant = result[0]
        avg_retry = float(result[4] or 0)
        completion_rate = float(result[5] or 0)
        avg_score = float(result[9] or 0)

        recommendations = {
            "suggested_feedback_style": "supportive",  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            "focus_areas": [],
            "avoid_patterns": []
        }

        # ãƒªãƒˆãƒ©ã‚¤å›æ•°ãŒå¤šã„å ´åˆã¯å„ªã—ã„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
        if avg_retry > 2:
            recommendations["suggested_feedback_style"] = "gentle"
            recommendations["focus_areas"].append("ã‚ˆã‚Šå…·ä½“çš„ãªä¾‹ã‚’æç¤º")

        # å®Œäº†ç‡ãŒä½ã„å ´åˆ
        if completion_rate < 50:
            recommendations["focus_areas"].append("å°ã•ãªã‚¹ãƒ†ãƒƒãƒ—ã‹ã‚‰å§‹ã‚ã‚‹")

        # å…·ä½“æ€§ã‚¹ã‚³ã‚¢ãŒä½ã„å ´åˆ
        if avg_score < 0.5:
            recommendations["focus_areas"].append("æ•°å€¤ã‚„æœŸé™ã®ä¾‹ã‚’å¤šãæç¤º")

        # æœ€é »å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãæ¨å¥¨
        if dominant == "ng_abstract":
            recommendations["avoid_patterns"].append("æŠ½è±¡çš„ãªè¡¨ç¾")
            recommendations["focus_areas"].append("å…·ä½“çš„ãªæ•°å€¤ç›®æ¨™ã®ä¾‹ã‚’æç¤º")
        elif dominant == "ng_other_blame":
            recommendations["focus_areas"].append("è‡ªåˆ†ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã‚‹ã“ã¨ã«ç„¦ç‚¹")

        return recommendations


class GoalHistoryProvider:
    """
    éå»ã®ç›®æ¨™ãƒ»é€²æ—ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æä¾›

    ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®éå»ã®ç›®æ¨™è¨­å®šå±¥æ­´ã‚’å–å¾—ã—ã€
    æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„è‹¦æ‰‹ã‚¨ãƒªã‚¢ã‚’åˆ†æã™ã‚‹ã€‚

    ä½¿ç”¨ä¾‹:
        provider = GoalHistoryProvider(conn, org_id)
        context = provider.get_past_goals_context(user_id)
    """

    def __init__(self, conn, org_id: str):
        """
        åˆæœŸåŒ–

        Args:
            conn: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
            org_id: çµ„ç¹”IDï¼ˆãƒ†ãƒŠãƒ³ãƒˆåˆ†é›¢ç”¨ï¼‰
        """
        self.conn = conn
        self.org_id = str(org_id) if org_id else None

    def get_past_goals_context(
        self,
        user_id: str,
        limit: int = 5
    ) -> Dict[str, Any]:
        """
        éå»ã®ç›®æ¨™å±¥æ­´ã‚’å–å¾—

        Args:
            user_id: ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
            limit: å–å¾—ä»¶æ•°

        Returns:
            éå»ç›®æ¨™ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¾æ›¸
        """
        if not self.org_id or not user_id:
            return {
                "past_goals": [],
                "success_patterns": [],
                "struggle_areas": [],
                "avg_achievement_rate": 0
            }

        try:
            # goalsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰éå»ã®ç›®æ¨™ã‚’å–å¾—
            result = self.conn.execute(
                text("""
                    SELECT
                        g.id,
                        g.title,
                        g.description,
                        g.status,
                        g.target_value,
                        g.current_value,
                        g.deadline,
                        g.created_at
                    FROM goals g
                    WHERE g.organization_id = :org_id
                      AND g.user_id = :user_id
                    ORDER BY g.created_at DESC
                    LIMIT :limit
                """),
                {
                    "org_id": self.org_id,
                    "user_id": str(user_id),
                    "limit": limit
                }
            ).fetchall()

            past_goals = []
            total_achievement = 0
            completed_count = 0

            for row in result:
                goal = {
                    "id": str(row[0]),
                    "title": row[1],
                    "description": row[2],
                    "status": row[3],
                    "target_value": float(row[4]) if row[4] else None,
                    "current_value": float(row[5]) if row[5] else None,
                    "deadline": row[6].isoformat() if row[6] else None,
                    "created_at": row[7].isoformat() if row[7] else None
                }

                # é”æˆç‡ã‚’è¨ˆç®—
                if goal["target_value"] and goal["current_value"]:
                    goal["achievement_rate"] = min(
                        (goal["current_value"] / goal["target_value"]) * 100,
                        100
                    )
                    total_achievement += goal["achievement_rate"]
                    completed_count += 1
                else:
                    goal["achievement_rate"] = 0

                # WHY/WHAT/HOWã‚’æŠ½å‡ºï¼ˆdescriptionã‹ã‚‰ï¼‰
                self._extract_why_what_how(goal)

                past_goals.append(goal)

            # æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è‹¦æ‰‹ã‚¨ãƒªã‚¢ã‚’åˆ†æ
            analysis = self._analyze_patterns(past_goals)

            return {
                "past_goals": past_goals,
                "success_patterns": analysis["success_patterns"],
                "struggle_areas": analysis["struggle_areas"],
                "avg_achievement_rate": (
                    total_achievement / completed_count if completed_count > 0 else 0
                )
            }

        except Exception as e:
            print(f"âš ï¸ éå»ç›®æ¨™å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "past_goals": [],
                "success_patterns": [],
                "struggle_areas": [],
                "avg_achievement_rate": 0
            }

    def _extract_why_what_how(self, goal: Dict[str, Any]) -> None:
        """descriptionã‹ã‚‰WHY/WHAT/HOWã‚’æŠ½å‡º"""
        description = goal.get("description", "") or ""

        # WHY: / WHAT: / HOW: ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œç´¢
        why_match = re.search(r'WHY[:ï¼š]\s*(.+?)(?=WHAT[:ï¼š]|HOW[:ï¼š]|$)', description, re.DOTALL)
        what_match = re.search(r'WHAT[:ï¼š]\s*(.+?)(?=HOW[:ï¼š]|$)', description, re.DOTALL)
        how_match = re.search(r'HOW[:ï¼š]\s*(.+?)$', description, re.DOTALL)

        goal["why"] = why_match.group(1).strip() if why_match else ""
        goal["what"] = what_match.group(1).strip() if what_match else ""
        goal["how"] = how_match.group(1).strip() if how_match else ""

    def _analyze_patterns(self, past_goals: list) -> Dict[str, list]:
        """éå»ç›®æ¨™ã‹ã‚‰æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è‹¦æ‰‹ã‚¨ãƒªã‚¢ã‚’åˆ†æ"""
        success_patterns = []
        struggle_areas = []

        high_achievement_goals = [g for g in past_goals if g.get("achievement_rate", 0) >= 80]
        low_achievement_goals = [g for g in past_goals if g.get("achievement_rate", 0) < 50]

        # æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
        for goal in high_achievement_goals:
            if goal.get("target_value"):
                success_patterns.append("æ•°å€¤ç›®æ¨™")
            if goal.get("how") and ("æ¯æ—¥" in goal["how"] or "æ¯é€±" in goal["how"]):
                success_patterns.append("ç¿’æ…£åŒ–")
            if goal.get("deadline"):
                success_patterns.append("æœŸé™è¨­å®š")

        # è‹¦æ‰‹ã‚¨ãƒªã‚¢ã‚’æŠ½å‡º
        for goal in low_achievement_goals:
            if not goal.get("target_value"):
                struggle_areas.append("æ•°å€¤ç›®æ¨™ã®è¨­å®š")
            if not goal.get("how"):
                struggle_areas.append("å…·ä½“çš„ãªè¡Œå‹•è¨ˆç”»")

        return {
            "success_patterns": list(set(success_patterns)),
            "struggle_areas": list(set(struggle_areas))
        }

    def get_goal_trend_analysis(self, user_id: str) -> Dict[str, Any]:
        """
        ç›®æ¨™é”æˆå‚¾å‘ã‚’åˆ†æ

        Args:
            user_id: ãƒ¦ãƒ¼ã‚¶ãƒ¼ID

        Returns:
            å‚¾å‘åˆ†æçµæœ
        """
        context = self.get_past_goals_context(user_id, limit=10)
        past_goals = context.get("past_goals", [])

        if not past_goals:
            return {
                "goal_type_preference": None,
                "period_preference": None,
                "progress_style": None,
                "weak_points": []
            }

        # ç›®æ¨™ã‚¿ã‚¤ãƒ—ã®å‚¾å‘
        numeric_count = sum(1 for g in past_goals if g.get("target_value"))
        goal_type_preference = "numeric" if numeric_count > len(past_goals) / 2 else "qualitative"

        return {
            "goal_type_preference": goal_type_preference,
            "period_preference": "monthly",  # TODO: å®Ÿéš›ã®æœŸé–“ã‚’åˆ†æ
            "progress_style": "steady",  # TODO: é€²æ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
            "weak_points": context.get("struggle_areas", [])
        }
